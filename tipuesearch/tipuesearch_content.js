var tipuesearch = {"pages":[{"title":" csv-fortran ","text":"csv-fortran Description A modern Fortran library for reading and writing CSV (comma-separated value) files. Latest Release Documentation The latest API documentation for the master branch can be found here . This was generated from the source code using FORD . Getting started Get the code git clone https://github.com/jacobwilliams/csv-fortran cd csv-fortran Dependencies Git fpm or CMake FORD (optional) Build with fortran-lang/fpm Fortran Package Manager (fpm) is a great package manager and build system for Fortran.\nYou can build using provided fpm.toml : fpm build To use csv-fortran within your fpm project, add the following to your fpm.toml file: [dependencies] csv-fortran = { git = \"https://github.com/jacobwilliams/csv-fortran.git\" } Examples Everything is handled by an object-oriented csv_file class. Here is an example for writing a file: program csv_write_test use csv_module use iso_fortran_env , only : wp => real64 implicit none type ( csv_file ) :: f logical :: status_ok ! set optional inputs: call f % initialize ( verbose = . true .) ! open the file call f % open ( 'test.csv' , n_cols = 4 , status_ok = status_ok ) ! add header call f % add ([ 'x' , 'y' , 'z' , 't' ]) call f % next_row () ! add some data: call f % add ([ 1.0_wp , 2.0_wp , 3.0_wp ], real_fmt = '(F5.3)' ) call f % add (. true .) call f % next_row () call f % add ([ 4.0_wp , 5.0_wp , 6.0_wp ], real_fmt = '(F5.3)' ) call f % add (. false .) call f % next_row () ! finished call f % close ( status_ok ) end program csv_write_test Which produces the following file: x,y,z,t\n1.000,2.000,3.000,T\n4.000,5.000,6.000,F Real, integer, logical, or character data can be added as scalars, vectors, and matrices. When reading a CSV file, the data is stored internally in the class as allocatable character strings, which can be retrieved as real, integer, logical or character vectors as necessary. For example, to get the x , y , z , and t vectors from the previously-generated file: program csv_read_test use csv_module use iso_fortran_env , only : wp => real64 implicit none type ( csv_file ) :: f character ( len = 30 ), dimension (:), allocatable :: header real ( wp ), dimension (:), allocatable :: x , y , z logical , dimension (:), allocatable :: t logical :: status_ok integer , dimension (:), allocatable :: itypes ! read the file call f % read ( 'test.csv' , header_row = 1 , status_ok = status_ok ) ! get the header and type info call f % get_header ( header , status_ok ) call f % variable_types ( itypes , status_ok ) ! get some data call f % get ( 1 , x , status_ok ) call f % get ( 2 , y , status_ok ) call f % get ( 3 , z , status_ok ) call f % get ( 4 , t , status_ok ) ! destroy the file call f % destroy () end program csv_read_test Various options are user-selectable for specifying the format (e.g., changing the quote or delimiter characters). You can choose to enclose strings (or all fields) in quotes or not. The library works pretty well, and there are probably additional improvements that could be made. For one thing, it doesn't properly handle the case of a string that contains the delimiter character (I'll eventually fix this). If anybody has any other improvements, fork it and send me a pull request. License This library is released under a BSD-3 license . Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"csv_string – csv-fortran ","text":"type, public :: csv_string a cell from a CSV file. This is used to store the data internally\nin the csv_file class. Inherited by type~~csv_string~~InheritedByGraph type~csv_string csv_string type~csv_file csv_file type~csv_file->type~csv_string header, csv_data Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str Source Code type , public :: csv_string !! a cell from a CSV file. !! !! This is used to store the data internally !! in the [[csv_file]] class. character ( len = :), allocatable :: str end type csv_string","tags":"","loc":"type/csv_string.html"},{"title":"csv_file – csv-fortran ","text":"type, public :: csv_file the main class for reading and writing CSV files. Note A CSV file is assumed to contain the same number\n      of columns in each row. It may optionally contain\n      a header row. Inherits type~~csv_file~~InheritsGraph type~csv_file csv_file type~csv_string csv_string type~csv_file->type~csv_string header, csv_data Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial logical, private :: verbose = .false. to print error messages character(len=1), private :: quote = '\"' quotation character character(len=1), private :: delimiter = ',' delimiter character integer, private :: n_rows = 0 number of rows in the file integer, private :: n_cols = 0 number of columns in the file integer, private :: chunk_size = 1024 for expanding vectors type( csv_string ), private, dimension(:), allocatable :: header the header type( csv_string ), private, dimension(:,:), allocatable :: csv_data the data in the file integer, private :: icol = 0 last column written in current row integer, private :: iunit = 0 file unit for writing logical, private :: enclose_strings_in_quotes = .true. if true, all string cells\nwill be enclosed in quotes. logical, private :: enclose_all_in_quotes = .false. if true, all cells will\nbe enclosed in quotes. character(len=1), private :: logical_true_string = 'T' when writing a logical true value to a CSV file, this\nis the string to use\n(default is T ) character(len=1), private :: logical_false_string = 'F' when writing a logical false value to a CSV file, this\nis the string to use\n(default is F ) Type-Bound Procedures procedure, public :: initialize => initialize_csv_file private  subroutine initialize_csv_file (me, quote, delimiter, enclose_strings_in_quotes, enclose_all_in_quotes, logical_true_string, logical_false_string, chunk_size, verbose) Initialize a csv_file . Arguments Type Intent Optional Attributes Name class( csv_file ), intent(out) :: me character(len=1), intent(in), optional :: quote (Default is \" ) character(len=1), intent(in), optional :: delimiter (Default is , ) logical, intent(in), optional :: enclose_strings_in_quotes if true, all string cells\nwill be enclosed in quotes.\n(Default is True) logical, intent(in), optional :: enclose_all_in_quotes if true, all cells will\nbe enclosed in quotes.\n(Default is False) character(len=1), intent(in), optional :: logical_true_string when writing a logical true value to a CSV file, this\nis the string to use\n(default is T ) character(len=1), intent(in), optional :: logical_false_string when writing a logical false value to a CSV file, this\nis the string to use\n(default is F ) integer, intent(in), optional :: chunk_size factor for expanding vectors\n(default is 100) logical, intent(in), optional :: verbose print error messages to the\nconsole (default is False) procedure, public :: read => read_csv_file private  subroutine read_csv_file (me, filename, header_row, skip_rows, status_ok, delimiter) Read a CSV file. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: filename the CSV file to open integer, intent(in), optional :: header_row the header row integer, intent(in), optional, dimension(:) :: skip_rows rows to skip logical, intent(out) :: status_ok status flag character(len=1), intent(in), optional :: delimiter (Default is , ) procedure, public :: destroy => destroy_csv_file private  subroutine destroy_csv_file (me) Destroy the data in a CSV file. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(out) :: me procedure, public :: variable_types private  subroutine variable_types (me, itypes, status_ok) Returns an array indicating the variable type of each columns. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: itypes logical, intent(out) :: status_ok generic, public :: get_header => get_header_str , get_header_csv_str private  subroutine get_header_str (me, header, status_ok) Returns the header as a character(len=*) array.\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok private  subroutine get_header_csv_str (me, header, status_ok) Returns the header as a type(csv_string) array.\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me type( csv_string ), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok procedure, private :: get_header_str private  subroutine get_header_str (me, header, status_ok) Returns the header as a character(len=*) array.\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok procedure, private :: get_header_csv_str private  subroutine get_header_csv_str (me, header, status_ok) Returns the header as a type(csv_string) array.\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me type( csv_string ), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok generic, public :: get => get_csv_data_as_str , csv_get_value , get_real_sp_column , get_real_wp_column , get_integer_column , get_logical_column , get_character_column , get_csv_string_column For getting data from the class\nafter the file has been read. private  subroutine get_csv_data_as_str (me, csv_data, status_ok) Returns a character(len=*) array containing the csv data\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:,:), allocatable :: csv_data the data logical, intent(out) :: status_ok status flag private  subroutine csv_get_value (me, row, col, val, status_ok) Get an individual value from the csv_data structure in the CSV class. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: row row number integer, intent(in) :: col column number class(*), intent(out) :: val the returned value logical, intent(out) :: status_ok status flag private  subroutine get_real_sp_column (me, icol, r, status_ok) Return a column from a CSV file as a real(sp) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=sp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_real_wp_column (me, icol, r, status_ok) Return a column from a CSV file as a real(wp) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=wp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_integer_column (me, icol, r, status_ok) Return a column from a CSV file as a integer(ip) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number integer(kind=ip), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_logical_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a logical vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number logical, intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_character_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a character(len=*) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number character(len=*), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_csv_string_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a type(csv_string) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number type( csv_string ), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok procedure, private :: get_csv_data_as_str private  subroutine get_csv_data_as_str (me, csv_data, status_ok) Returns a character(len=*) array containing the csv data\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:,:), allocatable :: csv_data the data logical, intent(out) :: status_ok status flag procedure, private :: csv_get_value private  subroutine csv_get_value (me, row, col, val, status_ok) Get an individual value from the csv_data structure in the CSV class. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: row row number integer, intent(in) :: col column number class(*), intent(out) :: val the returned value logical, intent(out) :: status_ok status flag procedure, private :: get_real_sp_column private  subroutine get_real_sp_column (me, icol, r, status_ok) Return a column from a CSV file as a real(sp) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=sp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok procedure, private :: get_real_wp_column private  subroutine get_real_wp_column (me, icol, r, status_ok) Return a column from a CSV file as a real(wp) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=wp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok procedure, private :: get_integer_column private  subroutine get_integer_column (me, icol, r, status_ok) Return a column from a CSV file as a integer(ip) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number integer(kind=ip), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok procedure, private :: get_logical_column private  subroutine get_logical_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a logical vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number logical, intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok procedure, private :: get_character_column private  subroutine get_character_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a character(len=*) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number character(len=*), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok procedure, private :: get_csv_string_column private  subroutine get_csv_string_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a type(csv_string) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number type( csv_string ), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok procedure, public :: open => open_csv_file private  subroutine open_csv_file (me, filename, n_cols, status_ok, append) Open a CSV file for writing. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: filename the CSV file to open integer, intent(in) :: n_cols number of columns in the file logical, intent(out) :: status_ok status flag logical, intent(in), optional :: append append if file exists generic, public :: add => add_cell , add_vector , add_matrix private  subroutine add_cell (me, val, int_fmt, real_fmt, trim_str) Add a cell to a CSV file. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in) :: val the value to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. private  subroutine add_vector (me, val, int_fmt, real_fmt, trim_str) Add a vector to a CSV file. Each element is added as a cell to the current line. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. private  subroutine add_matrix (me, val, int_fmt, real_fmt, trim_str) Add a matrix to a CSV file. Each row is added as a new line.\nLine breaks are added at the end of each line (in this way it\ndiffers from the other add routines). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:,:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. procedure, private :: add_cell private  subroutine add_cell (me, val, int_fmt, real_fmt, trim_str) Add a cell to a CSV file. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in) :: val the value to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. procedure, private :: add_vector private  subroutine add_vector (me, val, int_fmt, real_fmt, trim_str) Add a vector to a CSV file. Each element is added as a cell to the current line. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. procedure, private :: add_matrix private  subroutine add_matrix (me, val, int_fmt, real_fmt, trim_str) Add a matrix to a CSV file. Each row is added as a new line.\nLine breaks are added at the end of each line (in this way it\ndiffers from the other add routines). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:,:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. procedure, public :: next_row private  subroutine next_row (me) Advance to the next row in the CSV file\n(write any blank cells that are necessary to finish the row) Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me procedure, public :: close => close_csv_file private  subroutine close_csv_file (me, status_ok) Close a CSV file after writing Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me logical, intent(out) :: status_ok status flag procedure, private :: tokenize => tokenize_csv_line private  subroutine tokenize_csv_line (me, line, cells) Tokenize a line from a CSV file. The result is an array of csv_string types. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: line type( csv_string ), intent(out), dimension(:), allocatable :: cells procedure, private :: read_line_from_file private  subroutine read_line_from_file (me, iunit, line, status_ok) Reads the next line from a file. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(in) :: me integer, intent(in) :: iunit character(len=:), intent(out), allocatable :: line logical, intent(out) :: status_ok true if no problems procedure, private :: get_column private  subroutine get_column (me, icol, r, status_ok) Return a column from a CSV file vector. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number class(*), intent(out), dimension(:) :: r assumed to have been allocated to\nthe correct size by the caller.\n( n_rows ) logical, intent(out) :: status_ok status flag Source Code type , public :: csv_file !! the main class for reading and writing CSV files. !! !!@note A CSV file is assumed to contain the same number !!      of columns in each row. It may optionally contain !!      a header row. private logical :: verbose = . false . !! to print error messages character ( len = 1 ) :: quote = '\"' !! quotation character character ( len = 1 ) :: delimiter = ',' !! delimiter character ! for reading a csv file: integer :: n_rows = 0 !! number of rows in the file integer :: n_cols = 0 !! number of columns in the file integer :: chunk_size = 1024 !! for expanding vectors type ( csv_string ), dimension (:), allocatable :: header !! the header type ( csv_string ), dimension (:,:), allocatable :: csv_data !! the data in the file ! for writing a csv file: integer :: icol = 0 !! last column written in current row integer :: iunit = 0 !! file unit for writing logical :: enclose_strings_in_quotes = . true . !! if true, all string cells !! will be enclosed in quotes. logical :: enclose_all_in_quotes = . false . !! if true, *all* cells will !! be enclosed in quotes. character ( len = 1 ) :: logical_true_string = 'T' !! when writing a logical `true` !! value to a CSV file, this !! is the string to use !! (default is `T`) character ( len = 1 ) :: logical_false_string = 'F' !! when writing a logical `false` !! value to a CSV file, this !! is the string to use !! (default is `F`) contains private procedure , public :: initialize => initialize_csv_file procedure , public :: read => read_csv_file procedure , public :: destroy => destroy_csv_file procedure , public :: variable_types generic , public :: get_header => get_header_str ,& get_header_csv_str procedure :: get_header_str procedure :: get_header_csv_str !> ! For getting data from the class ! after the file has been read. generic , public :: get => get_csv_data_as_str ,& csv_get_value ,& get_real_sp_column ,& get_real_wp_column ,& get_integer_column ,& get_logical_column ,& get_character_column ,& get_csv_string_column procedure :: get_csv_data_as_str procedure :: csv_get_value procedure :: get_real_sp_column procedure :: get_real_wp_column procedure :: get_integer_column procedure :: get_logical_column procedure :: get_character_column procedure :: get_csv_string_column procedure , public :: open => open_csv_file generic , public :: add => add_cell ,& add_vector ,& add_matrix procedure :: add_cell procedure :: add_vector procedure :: add_matrix procedure , public :: next_row procedure , public :: close => close_csv_file procedure :: tokenize => tokenize_csv_line procedure :: read_line_from_file procedure :: get_column end type csv_file","tags":"","loc":"type/csv_file.html"},{"title":"number_of_lines_in_file – csv-fortran","text":"private  function number_of_lines_in_file(iunit) result(n_lines) Returns the number of lines in a text file. Note It rewinds the file back to the beginning when finished. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file Called by proc~~number_of_lines_in_file~~CalledByGraph proc~number_of_lines_in_file number_of_lines_in_file proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~number_of_lines_in_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function number_of_lines_in_file ( iunit ) result ( n_lines ) implicit none integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file","tags":"","loc":"proc/number_of_lines_in_file.html"},{"title":"initialize_csv_file – csv-fortran","text":"private  subroutine initialize_csv_file(me, quote, delimiter, enclose_strings_in_quotes, enclose_all_in_quotes, logical_true_string, logical_false_string, chunk_size, verbose) Initialize a csv_file . Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(out) :: me character(len=1), intent(in), optional :: quote (Default is \" ) character(len=1), intent(in), optional :: delimiter (Default is , ) logical, intent(in), optional :: enclose_strings_in_quotes if true, all string cells\nwill be enclosed in quotes.\n(Default is True) logical, intent(in), optional :: enclose_all_in_quotes if true, all cells will\nbe enclosed in quotes.\n(Default is False) character(len=1), intent(in), optional :: logical_true_string when writing a logical true value to a CSV file, this\nis the string to use\n(default is T ) character(len=1), intent(in), optional :: logical_false_string when writing a logical false value to a CSV file, this\nis the string to use\n(default is F ) integer, intent(in), optional :: chunk_size factor for expanding vectors\n(default is 100) logical, intent(in), optional :: verbose print error messages to the\nconsole (default is False) Source Code subroutine initialize_csv_file ( me , quote , delimiter ,& enclose_strings_in_quotes ,& enclose_all_in_quotes ,& logical_true_string ,& logical_false_string ,& chunk_size ,& verbose ) implicit none class ( csv_file ), intent ( out ) :: me character ( len = 1 ), intent ( in ), optional :: quote !! note: can only be one character !! (Default is `\"`) character ( len = 1 ), intent ( in ), optional :: delimiter !! note: can only be one character !! (Default is `,`) logical , intent ( in ), optional :: enclose_strings_in_quotes !! if true, all string cells !! will be enclosed in quotes. !! (Default is True) logical , intent ( in ), optional :: enclose_all_in_quotes !! if true, *all* cells will !! be enclosed in quotes. !! (Default is False) character ( len = 1 ), intent ( in ), optional :: logical_true_string !! when writing a logical `true` !! value to a CSV file, this !! is the string to use !! (default is `T`) character ( len = 1 ), intent ( in ), optional :: logical_false_string !! when writing a logical `false` !! value to a CSV file, this !! is the string to use !! (default is `F`) integer , intent ( in ), optional :: chunk_size !! factor for expanding vectors !! (default is 100) logical , intent ( in ), optional :: verbose !! print error messages to the !! console (default is False) if ( present ( quote )) me % quote = quote if ( present ( delimiter )) me % delimiter = delimiter if ( present ( enclose_strings_in_quotes )) & me % enclose_strings_in_quotes = enclose_strings_in_quotes if ( present ( enclose_all_in_quotes )) & me % enclose_all_in_quotes = enclose_all_in_quotes if ( present ( logical_true_string )) & me % logical_true_string = logical_true_string if ( present ( logical_false_string )) & me % logical_false_string = logical_false_string if ( present ( verbose )) me % verbose = verbose if ( present ( chunk_size )) me % chunk_size = chunk_size ! override: if ( me % enclose_all_in_quotes ) me % enclose_strings_in_quotes = . true . end subroutine initialize_csv_file","tags":"","loc":"proc/initialize_csv_file.html"},{"title":"destroy_csv_file – csv-fortran","text":"private  subroutine destroy_csv_file(me) Destroy the data in a CSV file. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(out) :: me Source Code subroutine destroy_csv_file ( me ) implicit none class ( csv_file ), intent ( out ) :: me end subroutine destroy_csv_file","tags":"","loc":"proc/destroy_csv_file.html"},{"title":"read_csv_file – csv-fortran","text":"private  subroutine read_csv_file(me, filename, header_row, skip_rows, status_ok, delimiter) Read a CSV file. rows in the file row counter in data array Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: filename the CSV file to open integer, intent(in), optional :: header_row the header row integer, intent(in), optional, dimension(:) :: skip_rows rows to skip logical, intent(out) :: status_ok status flag character(len=1), intent(in), optional :: delimiter (Default is , ) Calls proc~~read_csv_file~~CallsGraph proc~read_csv_file csv_file%read_csv_file proc~number_of_lines_in_file number_of_lines_in_file proc~read_csv_file->proc~number_of_lines_in_file proc~read_line_from_file csv_file%read_line_from_file proc~read_csv_file->proc~read_line_from_file proc~tokenize_csv_line csv_file%tokenize_csv_line proc~read_csv_file->proc~tokenize_csv_line proc~unique unique proc~read_csv_file->proc~unique proc~split split proc~tokenize_csv_line->proc~split proc~expand_vector expand_vector proc~unique->proc~expand_vector proc~sort_ascending sort_ascending proc~unique->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap proc~split->proc~expand_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_csv_file ( me , filename , header_row , skip_rows , status_ok , delimiter ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! the CSV file to open logical , intent ( out ) :: status_ok !! status flag integer , intent ( in ), optional :: header_row !! the header row integer , dimension (:), intent ( in ), optional :: skip_rows !! rows to skip character ( len = 1 ), intent ( in ), optional :: delimiter !! note: can only be one character !! (Default is `,`) type ( csv_string ), dimension (:), allocatable :: row_data !! a tokenized row integer , dimension (:), allocatable :: rows_to_skip !! the actual rows to skip character ( len = :), allocatable :: line !! a line from the file integer :: i !! counter integer :: j !! counter integer :: irow !! row counter integer :: n_rows_in_file !! number of lines in the file integer :: n_rows !! number of rows in the output data matrix integer :: n_cols !! number of columns in the file (and output data matrix) integer :: istat !! open status flag integer :: iunit !! open file unit logical :: arrays_allocated !! if the arrays in the !! class have been allocated integer :: iheader !! row number of header row !! (0 if no header specified) character ( len = 1 ) :: tmp !! for skipping a row ! clear existing data: arrays_allocated = . false . if ( allocated ( me % csv_data )) deallocate ( me % csv_data ) if ( allocated ( me % header )) deallocate ( me % header ) if ( present ( delimiter )) me % delimiter = delimiter open ( newunit = iunit , file = filename , status = 'OLD' , iostat = istat ) if ( istat == 0 ) then !get number of lines in the file n_rows_in_file = number_of_lines_in_file ( iunit ) !get number of lines in the data array if ( present ( skip_rows )) then !get size of unique elements in skip_rows, !and subtract from n_rows_in_file rows_to_skip = unique ( skip_rows , chunk_size = me % chunk_size ) n_rows = n_rows_in_file - size ( rows_to_skip ) else n_rows = n_rows_in_file end if if ( present ( header_row )) then iheader = max ( 0 , header_row ) n_rows = n_rows - merge ( 0 , 1 , iheader == 0 ) else iheader = 0 end if me % n_rows = n_rows ! we don't know the number of columns ! until we parse the first row (or the header) !read each line in the file, parse it, and populate data irow = 0 do i = 1 , n_rows_in_file !! rows in the file ! skip row if necessary if ( allocated ( rows_to_skip )) then if ( any ( i == rows_to_skip )) then read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( istat /= 0 ) then if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error skipping row in file: ' // trim ( filename ) close ( unit = iunit , iostat = istat ) status_ok = . false . return end if cycle end if end if call me % read_line_from_file ( iunit , line , status_ok ) if (. not . status_ok ) return ! file read error call me % tokenize ( line , row_data ) if (. not . arrays_allocated ) then ! note: the number of columns is obtained ! from the first one read. It is assumed ! that each row has the same number of ! columns. n_cols = size ( row_data ) me % n_cols = n_cols allocate ( me % csv_data ( n_rows , n_cols )) if ( iheader /= 0 ) allocate ( me % header ( n_cols )) arrays_allocated = . true . end if if ( i == iheader ) then do j = 1 , me % n_cols me % header ( j )% str = row_data ( j )% str end do else irow = irow + 1 !! row counter in data array do j = 1 , n_cols me % csv_data ( irow , j ) = row_data ( j ) !%str end do end if end do ! close the file close ( unit = iunit , iostat = istat ) status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error opening file: ' // trim ( filename ) status_ok = . false . end if end subroutine read_csv_file","tags":"","loc":"proc/read_csv_file.html"},{"title":"open_csv_file – csv-fortran","text":"private  subroutine open_csv_file(me, filename, n_cols, status_ok, append) Open a CSV file for writing. Use initialize to set options for the CSV file. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: filename the CSV file to open integer, intent(in) :: n_cols number of columns in the file logical, intent(out) :: status_ok status flag logical, intent(in), optional :: append append if file exists Source Code subroutine open_csv_file ( me , filename , n_cols , status_ok , append ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! the CSV file to open integer , intent ( in ) :: n_cols !! number of columns in the file logical , intent ( out ) :: status_ok !! status flag logical , intent ( in ), optional :: append !! append if file exists integer :: istat !! open `iostat` flag logical :: append_flag !! local copy of `append` argument logical :: file_exists !! if the file exists ! clear existing data: if ( allocated ( me % csv_data )) deallocate ( me % csv_data ) if ( allocated ( me % header )) deallocate ( me % header ) me % n_cols = n_cols ! optional append argument: append_flag = . false . file_exists = . false . if ( present ( append )) then append_flag = append if ( append ) inquire ( file = filename , exist = file_exists ) end if if ( append_flag . and . file_exists ) then open ( newunit = me % iunit , file = filename , status = 'OLD' , position = 'APPEND' , iostat = istat ) else open ( newunit = me % iunit , file = filename , status = 'REPLACE' , iostat = istat ) end if if ( istat == 0 ) then status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error opening file: ' // trim ( filename ) status_ok = . false . end if end subroutine open_csv_file","tags":"","loc":"proc/open_csv_file.html"},{"title":"close_csv_file – csv-fortran","text":"private  subroutine close_csv_file(me, status_ok) Close a CSV file after writing Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me logical, intent(out) :: status_ok status flag Source Code subroutine close_csv_file ( me , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me logical , intent ( out ) :: status_ok !! status flag integer :: istat !! close `iostat` flag close ( me % iunit , iostat = istat ) status_ok = istat == 0 end subroutine close_csv_file","tags":"","loc":"proc/close_csv_file.html"},{"title":"add_cell – csv-fortran","text":"private  subroutine add_cell(me, val, int_fmt, real_fmt, trim_str) Add a cell to a CSV file. Todo Need to check the istat values for errors. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in) :: val the value to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. Called by proc~~add_cell~~CalledByGraph proc~add_cell csv_file%add_cell none~add csv_file%add none~add->proc~add_cell proc~add_matrix csv_file%add_matrix none~add->proc~add_matrix proc~add_vector csv_file%add_vector none~add->proc~add_vector proc~add_matrix->none~add proc~add_vector->none~add Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_cell ( me , val , int_fmt , real_fmt , trim_str ) implicit none class ( csv_file ), intent ( inout ) :: me class ( * ), intent ( in ) :: val !! the value to add character ( len =* ), intent ( in ), optional :: int_fmt !! if `val` is an integer, use !! this format string. character ( len =* ), intent ( in ), optional :: real_fmt !! if `val` is a real, use !! this format string. logical , intent ( in ), optional :: trim_str !! if `val` is a string, then trim it. integer :: istat !! write `iostat` flag character ( len = :), allocatable :: ifmt !! actual format string to use for integers character ( len = :), allocatable :: rfmt !! actual format string to use for reals logical :: trimstr !! if the strings are to be trimmed character ( len = max_real_str_len ) :: real_val !! for writing a real value character ( len = max_integer_str_len ) :: int_val !! for writing an integer value ! make sure the row isn't already finished if ( me % icol < me % n_cols ) then me % icol = me % icol + 1 if ( me % enclose_all_in_quotes ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote end if select type ( val ) type is ( integer ( ip )) if ( present ( int_fmt )) then ifmt = trim ( adjustl ( int_fmt )) else ifmt = default_int_fmt end if write ( int_val , fmt = ifmt , iostat = istat ) val write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( adjustl ( int_val )) type is ( real ( sp )) if ( present ( real_fmt )) then rfmt = trim ( adjustl ( real_fmt )) else rfmt = default_real_fmt end if write ( real_val , fmt = rfmt , iostat = istat ) val write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( adjustl ( real_val )) type is ( real ( wp )) if ( present ( real_fmt )) then rfmt = trim ( adjustl ( real_fmt )) else rfmt = default_real_fmt end if write ( real_val , fmt = rfmt , iostat = istat ) val write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( adjustl ( real_val )) type is ( logical ) if ( val ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % logical_true_string else write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % logical_false_string end if type is ( character ( len =* )) if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote if ( present ( trim_str )) then trimstr = trim_str else trimstr = . false . end if if ( trimstr ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( val ) else write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) val end if if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote type is ( csv_string ) if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote if ( present ( trim_str )) then trimstr = trim_str else trimstr = . false . end if if ( trimstr ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( val % str ) else write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) val % str end if if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote class default if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error: cannot write unknown variable type to CSV file.' end select if ( me % enclose_all_in_quotes ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote end if if ( me % icol < me % n_cols ) write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % delimiter else if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error: cannot write more cells to the current row.' end if end subroutine add_cell","tags":"","loc":"proc/add_cell.html"},{"title":"add_vector – csv-fortran","text":"private  subroutine add_vector(me, val, int_fmt, real_fmt, trim_str) Add a vector to a CSV file. Each element is added as a cell to the current line. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. Calls proc~~add_vector~~CallsGraph proc~add_vector csv_file%add_vector none~add csv_file%add proc~add_vector->none~add none~add->proc~add_vector proc~add_cell csv_file%add_cell none~add->proc~add_cell proc~add_matrix csv_file%add_matrix none~add->proc~add_matrix proc~add_matrix->none~add proc~next_row csv_file%next_row proc~add_matrix->proc~next_row Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_vector~~CalledByGraph proc~add_vector csv_file%add_vector none~add csv_file%add proc~add_vector->none~add none~add->proc~add_vector proc~add_matrix csv_file%add_matrix none~add->proc~add_matrix proc~add_matrix->none~add Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_vector ( me , val , int_fmt , real_fmt , trim_str ) implicit none class ( csv_file ), intent ( inout ) :: me class ( * ), dimension (:), intent ( in ) :: val !! the values to add character ( len =* ), intent ( in ), optional :: int_fmt !! if `val` is an integer, use !! this format string. character ( len =* ), intent ( in ), optional :: real_fmt !! if `val` is a real, use !! this format string. logical , intent ( in ), optional :: trim_str !! if `val` is a string, then trim it. integer :: i !! counter do i = 1 , size ( val ) #if ( defined __GFORTRAN__ ) && ( __GNUC__ <= 10 ) ! This is a stupid workaround for gfortran bugs (tested with 7.2.0) select type ( val ) type is ( character ( len =* )) call me % add ( val ( i ), int_fmt , real_fmt , trim_str ) class default call me % add ( val ( i ), int_fmt , real_fmt , trim_str ) end select #else call me % add ( val ( i ), int_fmt , real_fmt , trim_str ) #endif end do end subroutine add_vector","tags":"","loc":"proc/add_vector.html"},{"title":"add_matrix – csv-fortran","text":"private  subroutine add_matrix(me, val, int_fmt, real_fmt, trim_str) Add a matrix to a CSV file. Each row is added as a new line.\nLine breaks are added at the end of each line (in this way it\ndiffers from the other add routines). Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:,:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. Calls proc~~add_matrix~~CallsGraph proc~add_matrix csv_file%add_matrix none~add csv_file%add proc~add_matrix->none~add proc~next_row csv_file%next_row proc~add_matrix->proc~next_row none~add->proc~add_matrix proc~add_cell csv_file%add_cell none~add->proc~add_cell proc~add_vector csv_file%add_vector none~add->proc~add_vector proc~add_vector->none~add Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_matrix~~CalledByGraph proc~add_matrix csv_file%add_matrix none~add csv_file%add proc~add_matrix->none~add none~add->proc~add_matrix proc~add_vector csv_file%add_vector none~add->proc~add_vector proc~add_vector->none~add Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_matrix ( me , val , int_fmt , real_fmt , trim_str ) implicit none class ( csv_file ), intent ( inout ) :: me class ( * ), dimension (:,:), intent ( in ) :: val !! the values to add character ( len =* ), intent ( in ), optional :: int_fmt !! if `val` is an integer, use !! this format string. character ( len =* ), intent ( in ), optional :: real_fmt !! if `val` is a real, use !! this format string. logical , intent ( in ), optional :: trim_str !! if `val` is a string, then trim it. integer :: i !! counter ! add each row: do i = 1 , size ( val , 1 ) call me % add ( val ( i ,:), int_fmt , real_fmt , trim_str ) call me % next_row () end do end subroutine add_matrix","tags":"","loc":"proc/add_matrix.html"},{"title":"next_row – csv-fortran","text":"private  subroutine next_row(me) Advance to the next row in the CSV file\n(write any blank cells that are necessary to finish the row) Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me Called by proc~~next_row~~CalledByGraph proc~next_row csv_file%next_row proc~add_matrix csv_file%add_matrix proc~add_matrix->proc~next_row none~add csv_file%add proc~add_matrix->none~add none~add->proc~add_matrix proc~add_vector csv_file%add_vector none~add->proc~add_vector proc~add_vector->none~add Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine next_row ( me ) implicit none class ( csv_file ), intent ( inout ) :: me integer :: i !! counter integer :: n !! number of blank cells to write if ( me % icol > 0 ) then n = me % n_cols - me % icol do i = 1 , n if ( i == n ) then !no trailing delimiter if ( me % enclose_strings_in_quotes ) then write ( me % iunit , '(A)' , advance = 'NO' ) me % quote // me % quote end if else if ( me % enclose_strings_in_quotes ) then write ( me % iunit , '(A)' , advance = 'NO' ) me % quote // me % quote // me % delimiter else write ( me % iunit , '(A)' , advance = 'NO' ) me % delimiter end if end if end do write ( me % iunit , '(A)' ) '' ! new line end if me % icol = 0 ! this row is finished end subroutine next_row","tags":"","loc":"proc/next_row.html"},{"title":"get_header_csv_str – csv-fortran","text":"private  subroutine get_header_csv_str(me, header, status_ok) Returns the header as a type(csv_string) array.\n( read must have already been called to read the file). Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me type( csv_string ), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok Source Code subroutine get_header_csv_str ( me , header , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me type ( csv_string ), dimension (:), allocatable , intent ( out ) :: header logical , intent ( out ) :: status_ok integer :: i !! column counter if ( allocated ( me % header )) then allocate ( header ( me % n_cols )) do i = 1 , me % n_cols header ( i ) = me % header ( i ) end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) 'Error: no header in class.' status_ok = . false . end if end subroutine get_header_csv_str","tags":"","loc":"proc/get_header_csv_str.html"},{"title":"get_header_str – csv-fortran","text":"private  subroutine get_header_str(me, header, status_ok) Returns the header as a character(len=*) array.\n( read must have already been called to read the file). Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok Source Code subroutine get_header_str ( me , header , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), dimension (:), allocatable , intent ( out ) :: header logical , intent ( out ) :: status_ok integer :: i !! column counter if ( allocated ( me % header )) then allocate ( header ( me % n_cols )) do i = 1 , me % n_cols header ( i ) = me % header ( i )% str end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) 'Error: no header in class.' status_ok = . false . end if end subroutine get_header_str","tags":"","loc":"proc/get_header_str.html"},{"title":"get_csv_data_as_str – csv-fortran","text":"private  subroutine get_csv_data_as_str(me, csv_data, status_ok) Returns a character(len=*) array containing the csv data\n( read must have already been called to read the file). Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:,:), allocatable :: csv_data the data logical, intent(out) :: status_ok status flag Source Code subroutine get_csv_data_as_str ( me , csv_data , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), dimension (:,:), allocatable , intent ( out ) :: csv_data !! the data logical , intent ( out ) :: status_ok !! status flag integer :: i !! row counter integer :: j !! column counter if ( allocated ( me % csv_data )) then ! size the output array: allocate ( csv_data ( me % n_rows , me % n_cols )) ! convert each element to a string: do concurrent ( j = 1 : me % n_cols ) do concurrent ( i = 1 : me % n_rows ) csv_data ( i , j ) = me % csv_data ( i , j )% str end do end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_csv_data_as_str","tags":"","loc":"proc/get_csv_data_as_str.html"},{"title":"to_real_sp – csv-fortran","text":"private pure elemental subroutine to_real_sp(str, val, status_ok) Convert a string to a real(sp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=sp), intent(out) :: val logical, intent(out) :: status_ok Called by proc~~to_real_sp~~CalledByGraph proc~to_real_sp to_real_sp proc~csv_get_value csv_file%csv_get_value proc~csv_get_value->proc~to_real_sp proc~get_column csv_file%get_column proc~get_column->proc~csv_get_value proc~get_character_column csv_file%get_character_column proc~get_character_column->proc~get_column proc~get_csv_string_column csv_file%get_csv_string_column proc~get_csv_string_column->proc~get_column proc~get_integer_column csv_file%get_integer_column proc~get_integer_column->proc~get_column proc~get_logical_column csv_file%get_logical_column proc~get_logical_column->proc~get_column proc~get_real_sp_column csv_file%get_real_sp_column proc~get_real_sp_column->proc~get_column proc~get_real_wp_column csv_file%get_real_wp_column proc~get_real_wp_column->proc~get_column Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine to_real_sp ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str real ( sp ), intent ( out ) :: val logical , intent ( out ) :: status_ok integer :: istat !! read `iostat` error code read ( str , fmt =* , iostat = istat ) val if ( istat == 0 ) then status_ok = . true . else status_ok = . false . val = zero end if end subroutine to_real_sp","tags":"","loc":"proc/to_real_sp.html"},{"title":"to_real_wp – csv-fortran","text":"private pure elemental subroutine to_real_wp(str, val, status_ok) Convert a string to a real(wp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=wp), intent(out) :: val logical, intent(out) :: status_ok Called by proc~~to_real_wp~~CalledByGraph proc~to_real_wp to_real_wp proc~csv_get_value csv_file%csv_get_value proc~csv_get_value->proc~to_real_wp proc~infer_variable_type infer_variable_type proc~infer_variable_type->proc~to_real_wp proc~get_column csv_file%get_column proc~get_column->proc~csv_get_value proc~variable_types csv_file%variable_types proc~variable_types->proc~infer_variable_type proc~get_character_column csv_file%get_character_column proc~get_character_column->proc~get_column proc~get_csv_string_column csv_file%get_csv_string_column proc~get_csv_string_column->proc~get_column proc~get_integer_column csv_file%get_integer_column proc~get_integer_column->proc~get_column proc~get_logical_column csv_file%get_logical_column proc~get_logical_column->proc~get_column proc~get_real_sp_column csv_file%get_real_sp_column proc~get_real_sp_column->proc~get_column proc~get_real_wp_column csv_file%get_real_wp_column proc~get_real_wp_column->proc~get_column Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine to_real_wp ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str real ( wp ), intent ( out ) :: val logical , intent ( out ) :: status_ok integer :: istat !! read `iostat` error code read ( str , fmt =* , iostat = istat ) val if ( istat == 0 ) then status_ok = . true . else status_ok = . false . val = zero end if end subroutine to_real_wp","tags":"","loc":"proc/to_real_wp.html"},{"title":"to_integer – csv-fortran","text":"private pure elemental subroutine to_integer(str, val, status_ok) Convert a string to a integer(ip) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=ip), intent(out) :: val logical, intent(out) :: status_ok Called by proc~~to_integer~~CalledByGraph proc~to_integer to_integer proc~csv_get_value csv_file%csv_get_value proc~csv_get_value->proc~to_integer proc~infer_variable_type infer_variable_type proc~infer_variable_type->proc~to_integer proc~get_column csv_file%get_column proc~get_column->proc~csv_get_value proc~variable_types csv_file%variable_types proc~variable_types->proc~infer_variable_type proc~get_character_column csv_file%get_character_column proc~get_character_column->proc~get_column proc~get_csv_string_column csv_file%get_csv_string_column proc~get_csv_string_column->proc~get_column proc~get_integer_column csv_file%get_integer_column proc~get_integer_column->proc~get_column proc~get_logical_column csv_file%get_logical_column proc~get_logical_column->proc~get_column proc~get_real_sp_column csv_file%get_real_sp_column proc~get_real_sp_column->proc~get_column proc~get_real_wp_column csv_file%get_real_wp_column proc~get_real_wp_column->proc~get_column Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine to_integer ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str integer ( ip ), intent ( out ) :: val logical , intent ( out ) :: status_ok integer :: istat !! read `iostat` error code read ( str , fmt = default_int_fmt , iostat = istat ) val if ( istat == 0 ) then status_ok = . true . else status_ok = . false . val = 0 end if end subroutine to_integer","tags":"","loc":"proc/to_integer.html"},{"title":"to_logical – csv-fortran","text":"private pure elemental subroutine to_logical(str, val, status_ok) Convert a string to a logical Evaluates to .true. for strings ['1','t','true','.true.'] Evaluates to .false. for strings ['0','f','false','.false.'] The string match is not case sensitive. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str logical, intent(out) :: val logical, intent(out) :: status_ok Calls proc~~to_logical~~CallsGraph proc~to_logical to_logical proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~to_logical~~CalledByGraph proc~to_logical to_logical proc~csv_get_value csv_file%csv_get_value proc~csv_get_value->proc~to_logical proc~infer_variable_type infer_variable_type proc~infer_variable_type->proc~to_logical proc~get_column csv_file%get_column proc~get_column->proc~csv_get_value proc~variable_types csv_file%variable_types proc~variable_types->proc~infer_variable_type proc~get_character_column csv_file%get_character_column proc~get_character_column->proc~get_column proc~get_csv_string_column csv_file%get_csv_string_column proc~get_csv_string_column->proc~get_column proc~get_integer_column csv_file%get_integer_column proc~get_integer_column->proc~get_column proc~get_logical_column csv_file%get_logical_column proc~get_logical_column->proc~get_column proc~get_real_sp_column csv_file%get_real_sp_column proc~get_real_sp_column->proc~get_column proc~get_real_wp_column csv_file%get_real_wp_column proc~get_real_wp_column->proc~get_column Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine to_logical ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str logical , intent ( out ) :: val logical , intent ( out ) :: status_ok character ( len = :), allocatable :: tmp ! True and False options (all lowercase): character ( len =* ), dimension ( 4 ), parameter :: true_str = [ '1     ' ,& 't     ' ,& 'true  ' ,& '.true.' ] character ( len =* ), dimension ( 4 ), parameter :: false_str = [ '0      ' ,& 'f      ' ,& 'false  ' ,& '.false.' ] tmp = lowercase_string ( str ) if ( any ( tmp == true_str ) ) then val = . true . status_ok = . true . else if ( any ( tmp == false_str ) ) then val = . false . status_ok = . true . else val = . false . status_ok = . false . end if end subroutine to_logical","tags":"","loc":"proc/to_logical.html"},{"title":"variable_types – csv-fortran","text":"private  subroutine variable_types(me, itypes, status_ok) Returns an array indicating the variable type of each columns. Note The first element in the column is used to determine the type. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: itypes logical, intent(out) :: status_ok Calls proc~~variable_types~~CallsGraph proc~variable_types csv_file%variable_types proc~infer_variable_type infer_variable_type proc~variable_types->proc~infer_variable_type proc~to_integer to_integer proc~infer_variable_type->proc~to_integer proc~to_logical to_logical proc~infer_variable_type->proc~to_logical proc~to_real_wp to_real_wp proc~infer_variable_type->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine variable_types ( me , itypes , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: itypes logical , intent ( out ) :: status_ok integer :: i !! counter if ( allocated ( me % csv_data )) then allocate ( itypes ( me % n_cols )) do i = 1 , me % n_cols call infer_variable_type ( me % csv_data ( 1 , i )% str , itypes ( i )) end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine variable_types","tags":"","loc":"proc/variable_types.html"},{"title":"infer_variable_type – csv-fortran","text":"private  subroutine infer_variable_type(str, itype) Infers the variable type, assuming the following precedence: integer double logical character Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(out) :: itype Calls proc~~infer_variable_type~~CallsGraph proc~infer_variable_type infer_variable_type proc~to_integer to_integer proc~infer_variable_type->proc~to_integer proc~to_logical to_logical proc~infer_variable_type->proc~to_logical proc~to_real_wp to_real_wp proc~infer_variable_type->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~infer_variable_type~~CalledByGraph proc~infer_variable_type infer_variable_type proc~variable_types csv_file%variable_types proc~variable_types->proc~infer_variable_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine infer_variable_type ( str , itype ) implicit none character ( len =* ), intent ( in ) :: str integer , intent ( out ) :: itype real ( wp ) :: rval !! a real value integer ( ip ) :: ival !! an iteger value logical :: lval !! a logical value logical :: status_ok !! status flag call to_integer ( str , ival , status_ok ) if ( status_ok ) then itype = csv_type_integer return end if call to_real_wp ( str , rval , status_ok ) if ( status_ok ) then itype = csv_type_double return end if call to_logical ( str , lval , status_ok ) if ( status_ok ) then itype = csv_type_logical return end if ! default is string: itype = csv_type_string end subroutine infer_variable_type","tags":"","loc":"proc/infer_variable_type.html"},{"title":"csv_get_value – csv-fortran","text":"private  subroutine csv_get_value(me, row, col, val, status_ok) Get an individual value from the csv_data structure in the CSV class. The output val can be an integer(ip) , real(wp) , logical , or character(len=*) variable. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: row row number integer, intent(in) :: col column number class(*), intent(out) :: val the returned value logical, intent(out) :: status_ok status flag Calls proc~~csv_get_value~~CallsGraph proc~csv_get_value csv_file%csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~csv_get_value~~CalledByGraph proc~csv_get_value csv_file%csv_get_value proc~get_column csv_file%get_column proc~get_column->proc~csv_get_value proc~get_character_column csv_file%get_character_column proc~get_character_column->proc~get_column proc~get_csv_string_column csv_file%get_csv_string_column proc~get_csv_string_column->proc~get_column proc~get_integer_column csv_file%get_integer_column proc~get_integer_column->proc~get_column proc~get_logical_column csv_file%get_logical_column proc~get_logical_column->proc~get_column proc~get_real_sp_column csv_file%get_real_sp_column proc~get_real_sp_column->proc~get_column proc~get_real_wp_column csv_file%get_real_wp_column proc~get_real_wp_column->proc~get_column Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine csv_get_value ( me , row , col , val , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: row !! row number integer , intent ( in ) :: col !! column number class ( * ), intent ( out ) :: val !! the returned value logical , intent ( out ) :: status_ok !! status flag select type ( val ) type is ( integer ( ip )) call to_integer ( me % csv_data ( row , col )% str , val , status_ok ) type is ( real ( sp )) call to_real_sp ( me % csv_data ( row , col )% str , val , status_ok ) type is ( real ( wp )) call to_real_wp ( me % csv_data ( row , col )% str , val , status_ok ) type is ( logical ) call to_logical ( me % csv_data ( row , col )% str , val , status_ok ) type is ( character ( len =* )) status_ok = . true . if ( allocated ( me % csv_data ( row , col )% str )) then val = me % csv_data ( row , col )% str else val = '' end if type is ( csv_string ) status_ok = . true . val = me % csv_data ( row , col ) class default status_ok = . false . end select end subroutine csv_get_value","tags":"","loc":"proc/csv_get_value.html"},{"title":"get_column – csv-fortran","text":"private  subroutine get_column(me, icol, r, status_ok) Return a column from a CSV file vector. Note This routine requires that the r array already be allocated.\n      This is because Fortran doesn't want to allow to you pass\n      a non-polymorphic variable into a routine with a dummy variable\n      with class(*),dimension(:),allocatable,intent(out) attributes. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number class(*), intent(out), dimension(:) :: r assumed to have been allocated to\nthe correct size by the caller.\n( n_rows ) logical, intent(out) :: status_ok status flag Calls proc~~get_column~~CallsGraph proc~get_column csv_file%get_column proc~csv_get_value csv_file%csv_get_value proc~get_column->proc~csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_column~~CalledByGraph proc~get_column csv_file%get_column proc~get_character_column csv_file%get_character_column proc~get_character_column->proc~get_column proc~get_csv_string_column csv_file%get_csv_string_column proc~get_csv_string_column->proc~get_column proc~get_integer_column csv_file%get_integer_column proc~get_integer_column->proc~get_column proc~get_logical_column csv_file%get_logical_column proc~get_logical_column->proc~get_column proc~get_real_sp_column csv_file%get_real_sp_column proc~get_real_sp_column->proc~get_column proc~get_real_wp_column csv_file%get_real_wp_column proc~get_real_wp_column->proc~get_column Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number class ( * ), dimension (:), intent ( out ) :: r !! assumed to have been allocated to !! the correct size by the caller. !! (`n_rows`) logical , intent ( out ) :: status_ok !! status flag integer :: i !! counter character ( len = :), allocatable :: tmp !! for gfortran workaround ! we know the data is allocated, since that ! was checked by the calling routines. if ( me % n_cols >= icol . and . icol > 0 ) then do i = 1 , me % n_rows ! row loop #if ( defined __GFORTRAN__ ) && ( __GNUC__ <= 10 ) ! the following is a workaround for gfortran bugs: select type ( r ) type is ( character ( len =* )) tmp = repeat ( ' ' , len ( r )) ! size the string call me % csv_get_value ( i , icol , tmp , status_ok ) r ( i ) = tmp class default call me % csv_get_value ( i , icol , r ( i ), status_ok ) end select #else call me % csv_get_value ( i , icol , r ( i ), status_ok ) #endif if (. not . status_ok ) then select type ( r ) ! note: character conversion can never fail, so not ! checking for that here. also we know it is real, ! integer, or logical at this point. type is ( integer ( ip )) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to integer: ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = 0 type is ( real ( sp )) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to real(real32): ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = zero type is ( real ( wp )) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to real(real64): ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = zero type is ( logical ) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to logical: ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = . false . end select end if end do else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: invalid column number: ' , icol status_ok = . false . end if end subroutine get_column","tags":"","loc":"proc/get_column.html"},{"title":"get_real_sp_column – csv-fortran","text":"private  subroutine get_real_sp_column(me, icol, r, status_ok) Return a column from a CSV file as a real(sp) vector. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=sp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok Calls proc~~get_real_sp_column~~CallsGraph proc~get_real_sp_column csv_file%get_real_sp_column proc~get_column csv_file%get_column proc~get_real_sp_column->proc~get_column proc~csv_get_value csv_file%csv_get_value proc~get_column->proc~csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_real_sp_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number real ( sp ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_real_sp_column","tags":"","loc":"proc/get_real_sp_column.html"},{"title":"get_real_wp_column – csv-fortran","text":"private  subroutine get_real_wp_column(me, icol, r, status_ok) Return a column from a CSV file as a real(wp) vector. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=wp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok Calls proc~~get_real_wp_column~~CallsGraph proc~get_real_wp_column csv_file%get_real_wp_column proc~get_column csv_file%get_column proc~get_real_wp_column->proc~get_column proc~csv_get_value csv_file%csv_get_value proc~get_column->proc~csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_real_wp_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number real ( wp ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_real_wp_column","tags":"","loc":"proc/get_real_wp_column.html"},{"title":"get_integer_column – csv-fortran","text":"private  subroutine get_integer_column(me, icol, r, status_ok) Return a column from a CSV file as a integer(ip) vector. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number integer(kind=ip), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok Calls proc~~get_integer_column~~CallsGraph proc~get_integer_column csv_file%get_integer_column proc~get_column csv_file%get_column proc~get_integer_column->proc~get_column proc~csv_get_value csv_file%csv_get_value proc~get_column->proc~csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_integer_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number integer ( ip ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_integer_column","tags":"","loc":"proc/get_integer_column.html"},{"title":"get_logical_column – csv-fortran","text":"private  subroutine get_logical_column(me, icol, r, status_ok) Convert a column from a csv_string matrix to a logical vector. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number logical, intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok Calls proc~~get_logical_column~~CallsGraph proc~get_logical_column csv_file%get_logical_column proc~get_column csv_file%get_column proc~get_logical_column->proc~get_column proc~csv_get_value csv_file%csv_get_value proc~get_column->proc~csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_logical_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number logical , dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_logical_column","tags":"","loc":"proc/get_logical_column.html"},{"title":"get_character_column – csv-fortran","text":"private  subroutine get_character_column(me, icol, r, status_ok) Convert a column from a csv_string matrix to a character(len=*) vector. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number character(len=*), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok Calls proc~~get_character_column~~CallsGraph proc~get_character_column csv_file%get_character_column proc~get_column csv_file%get_column proc~get_character_column->proc~get_column proc~csv_get_value csv_file%csv_get_value proc~get_column->proc~csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_character_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number character ( len =* ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_character_column","tags":"","loc":"proc/get_character_column.html"},{"title":"get_csv_string_column – csv-fortran","text":"private  subroutine get_csv_string_column(me, icol, r, status_ok) Convert a column from a csv_string matrix to a type(csv_string) vector. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number type( csv_string ), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok Calls proc~~get_csv_string_column~~CallsGraph proc~get_csv_string_column csv_file%get_csv_string_column proc~get_column csv_file%get_column proc~get_csv_string_column->proc~get_column proc~csv_get_value csv_file%csv_get_value proc~get_column->proc~csv_get_value proc~to_integer to_integer proc~csv_get_value->proc~to_integer proc~to_logical to_logical proc~csv_get_value->proc~to_logical proc~to_real_sp to_real_sp proc~csv_get_value->proc~to_real_sp proc~to_real_wp to_real_wp proc~csv_get_value->proc~to_real_wp proc~lowercase_string lowercase_string proc~to_logical->proc~lowercase_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_csv_string_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number type ( csv_string ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_csv_string_column","tags":"","loc":"proc/get_csv_string_column.html"},{"title":"tokenize_csv_line – csv-fortran","text":"private  subroutine tokenize_csv_line(me, line, cells) Tokenize a line from a CSV file. The result is an array of csv_string types. Notes Quotes are removed if the entire cell is contained in quotes. Warning It does not account for delimiters in quotes\n         (these are treated as a new cell). Need to fix! Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: line type( csv_string ), intent(out), dimension(:), allocatable :: cells Calls proc~~tokenize_csv_line~~CallsGraph proc~tokenize_csv_line csv_file%tokenize_csv_line proc~split split proc~tokenize_csv_line->proc~split proc~expand_vector expand_vector proc~split->proc~expand_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~tokenize_csv_line~~CalledByGraph proc~tokenize_csv_line csv_file%tokenize_csv_line proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~tokenize_csv_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine tokenize_csv_line ( me , line , cells ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: line type ( csv_string ), dimension (:), allocatable , intent ( out ) :: cells integer :: i !! counter character ( len = :), allocatable :: tmp !! a temp string with whitespace removed integer :: n !! length of compressed string call split ( line , me % delimiter , me % chunk_size , cells ) ! remove quotes if present: do i = 1 , size ( cells ) ! remove whitespace from the string: tmp = trim ( adjustl ( cells ( i )% str )) n = len ( tmp ) if ( n > 1 ) then ! if the first and last non-blank character is ! a quote, then remove them and replace with what ! is inside the quotes. Otherwise, leave it as is. if ( tmp ( 1 : 1 ) == me % quote . and . tmp ( n : n ) == me % quote ) then if ( n > 2 ) then cells ( i )% str = tmp ( 2 : n - 1 ) ! remove the quotes else cells ( i )% str = '' ! empty string end if end if end if end do end subroutine tokenize_csv_line","tags":"","loc":"proc/tokenize_csv_line.html"},{"title":"read_line_from_file – csv-fortran","text":"private  subroutine read_line_from_file(me, iunit, line, status_ok) Reads the next line from a file. Type Bound csv_file Arguments Type Intent Optional Attributes Name class( csv_file ), intent(in) :: me integer, intent(in) :: iunit character(len=:), intent(out), allocatable :: line logical, intent(out) :: status_ok true if no problems Called by proc~~read_line_from_file~~CalledByGraph proc~read_line_from_file csv_file%read_line_from_file proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~read_line_from_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_line_from_file ( me , iunit , line , status_ok ) implicit none class ( csv_file ), intent ( in ) :: me integer , intent ( in ) :: iunit character ( len = :), allocatable , intent ( out ) :: line logical , intent ( out ) :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = me % chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Read error for file unit: ' , iunit status_ok = . false . exit end if end do end subroutine read_line_from_file","tags":"","loc":"proc/read_line_from_file.html"},{"title":"split – csv-fortran","text":"private pure subroutine split(str, token, chunk_size, vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Example character ( len = :), allocatable :: s type ( csv_string ), dimension (:), allocatable :: vals s = '1,2,3,4,5' call split ( s , ',' , vals ) Warning Does not account for tokens contained within quotes string !!! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token integer, intent(in) :: chunk_size for expanding vectors type( csv_string ), intent(out), dimension(:), allocatable :: vals Calls proc~~split~~CallsGraph proc~split split proc~expand_vector expand_vector proc~split->proc~expand_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~split~~CalledByGraph proc~split split proc~tokenize_csv_line csv_file%tokenize_csv_line proc~tokenize_csv_line->proc~split proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~tokenize_csv_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine split ( str , token , chunk_size , vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token integer , intent ( in ) :: chunk_size !! for expanding vectors type ( csv_string ), dimension (:), allocatable , intent ( out ) :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , chunk_size , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , chunk_size , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end subroutine split","tags":"","loc":"proc/split.html"},{"title":"unique – csv-fortran","text":"public  function unique(vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec Calls proc~~unique~~CallsGraph proc~unique unique proc~expand_vector expand_vector proc~unique->proc~expand_vector proc~sort_ascending sort_ascending proc~unique->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~unique~~CalledByGraph proc~unique unique proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~unique Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique","tags":"","loc":"proc/unique.html"},{"title":"lowercase_string – csv-fortran","text":"public pure function lowercase_string(str) result(s_lower) Returns lowercase version of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len=(len(str))) lowercase version of the string Called by proc~~lowercase_string~~CalledByGraph proc~lowercase_string lowercase_string proc~to_logical to_logical proc~to_logical->proc~lowercase_string proc~csv_get_value csv_file%csv_get_value proc~csv_get_value->proc~to_logical proc~infer_variable_type infer_variable_type proc~infer_variable_type->proc~to_logical proc~get_column csv_file%get_column proc~get_column->proc~csv_get_value proc~variable_types csv_file%variable_types proc~variable_types->proc~infer_variable_type proc~get_character_column csv_file%get_character_column proc~get_character_column->proc~get_column proc~get_csv_string_column csv_file%get_csv_string_column proc~get_csv_string_column->proc~get_column proc~get_integer_column csv_file%get_integer_column proc~get_integer_column->proc~get_column proc~get_logical_column csv_file%get_logical_column proc~get_logical_column->proc~get_column proc~get_real_sp_column csv_file%get_real_sp_column proc~get_real_sp_column->proc~get_column proc~get_real_wp_column csv_file%get_real_wp_column proc~get_real_wp_column->proc~get_column Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function lowercase_string ( str ) result ( s_lower ) implicit none character ( len =* ), intent ( in ) :: str !! input string character ( len = ( len ( str ))) :: s_lower !! lowercase version of the string integer :: i !! counter integer :: j !! index of uppercase character s_lower = str do i = 1 , len_trim ( str ) j = index ( upper , s_lower ( i : i )) if ( j > 0 ) s_lower ( i : i ) = lower ( j : j ) end do end function lowercase_string","tags":"","loc":"proc/lowercase_string.html"},{"title":"expand_vector – csv-fortran","text":"public pure subroutine expand_vector(vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) Called by proc~~expand_vector~~CalledByGraph proc~expand_vector expand_vector proc~split split proc~split->proc~expand_vector proc~unique unique proc~unique->proc~expand_vector proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~unique proc~tokenize_csv_line csv_file%tokenize_csv_line proc~read_csv_file->proc~tokenize_csv_line proc~tokenize_csv_line->proc~split Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine expand_vector ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector","tags":"","loc":"proc/expand_vector.html"},{"title":"sort_ascending – csv-fortran","text":"public  subroutine sort_ascending(ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending~~CallsGraph proc~sort_ascending sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending~~CalledByGraph proc~sort_ascending sort_ascending proc~unique unique proc~unique->proc~sort_ascending proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~unique Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do else if ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending","tags":"","loc":"proc/sort_ascending.html"},{"title":"swap – csv-fortran","text":"private pure elemental subroutine swap(i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2 Called by proc~~swap~~CalledByGraph proc~swap swap proc~sort_ascending sort_ascending proc~sort_ascending->proc~swap proc~unique unique proc~unique->proc~sort_ascending proc~read_csv_file csv_file%read_csv_file proc~read_csv_file->proc~unique Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental subroutine swap ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap","tags":"","loc":"proc/swap.html"},{"title":"csv_kinds – csv-fortran","text":"Numeric kinds. Uses iso_fortran_env module~~csv_kinds~~UsesGraph module~csv_kinds csv_kinds iso_fortran_env iso_fortran_env module~csv_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~csv_kinds~~UsedByGraph module~csv_kinds csv_kinds module~csv_module csv_module module~csv_module->module~csv_kinds module~csv_parameters csv_parameters module~csv_module->module~csv_parameters module~csv_utilities csv_utilities module~csv_module->module~csv_utilities module~csv_parameters->module~csv_kinds module~csv_utilities->module~csv_kinds module~csv_utilities->module~csv_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 default real kind integer, public, parameter :: sp = real32 additional real kind, single precision integer, public, parameter :: ip = int32 default integer kind","tags":"","loc":"module/csv_kinds.html"},{"title":"csv_module – csv-fortran","text":"For reading and writing CSV files. Uses csv_utilities iso_fortran_env csv_kinds csv_parameters module~~csv_module~~UsesGraph module~csv_module csv_module iso_fortran_env iso_fortran_env module~csv_module->iso_fortran_env module~csv_kinds csv_kinds module~csv_module->module~csv_kinds module~csv_parameters csv_parameters module~csv_module->module~csv_parameters module~csv_utilities csv_utilities module~csv_module->module~csv_utilities module~csv_kinds->iso_fortran_env module~csv_parameters->module~csv_kinds module~csv_utilities->module~csv_kinds module~csv_utilities->module~csv_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: csv_type_string = 1 a character string cell integer, public, parameter :: csv_type_double = 2 a real(wp) cell integer, public, parameter :: csv_type_integer = 3 an integer(ip) cell integer, public, parameter :: csv_type_logical = 4 a logical cell real(kind=wp), private, parameter :: zero = 0.0_wp Derived Types type, public :: csv_string a cell from a CSV file. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: str type, public :: csv_file the main class for reading and writing CSV files. Read more… Components Type Visibility Attributes Name Initial logical, private :: verbose = .false. to print error messages character(len=1), private :: quote = '\"' quotation character character(len=1), private :: delimiter = ',' delimiter character integer, private :: n_rows = 0 number of rows in the file integer, private :: n_cols = 0 number of columns in the file integer, private :: chunk_size = 1024 for expanding vectors type( csv_string ), private, dimension(:), allocatable :: header the header type( csv_string ), private, dimension(:,:), allocatable :: csv_data the data in the file integer, private :: icol = 0 last column written in current row integer, private :: iunit = 0 file unit for writing logical, private :: enclose_strings_in_quotes = .true. if true, all string cells\nwill be enclosed in quotes. logical, private :: enclose_all_in_quotes = .false. if true, all cells will\nbe enclosed in quotes. character(len=1), private :: logical_true_string = 'T' when writing a logical true value to a CSV file, this\nis the string to use\n(default is T ) character(len=1), private :: logical_false_string = 'F' when writing a logical false value to a CSV file, this\nis the string to use\n(default is F ) Type-Bound Procedures procedure, public :: initialize => initialize_csv_file procedure, public :: read => read_csv_file procedure, public :: destroy => destroy_csv_file procedure, public :: variable_types generic, public :: get_header => get_header_str , get_header_csv_str procedure, private :: get_header_str procedure, private :: get_header_csv_str generic, public :: get => get_csv_data_as_str , csv_get_value , get_real_sp_column , get_real_wp_column , get_integer_column , get_logical_column , get_character_column , get_csv_string_column ../../ For getting data from the class\nafter the file has been read. procedure, private :: get_csv_data_as_str procedure, private :: csv_get_value procedure, private :: get_real_sp_column procedure, private :: get_real_wp_column procedure, private :: get_integer_column procedure, private :: get_logical_column procedure, private :: get_character_column procedure, private :: get_csv_string_column procedure, public :: open => open_csv_file generic, public :: add => add_cell , add_vector , add_matrix procedure, private :: add_cell procedure, private :: add_vector procedure, private :: add_matrix procedure, public :: next_row procedure, public :: close => close_csv_file procedure, private :: tokenize => tokenize_csv_line procedure, private :: read_line_from_file procedure, private :: get_column Functions private  function number_of_lines_in_file (iunit) result(n_lines) Returns the number of lines in a text file. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: iunit the file unit number\n(assumed to be open) Return Value integer the number of lines in the file Subroutines private  subroutine initialize_csv_file (me, quote, delimiter, enclose_strings_in_quotes, enclose_all_in_quotes, logical_true_string, logical_false_string, chunk_size, verbose) Initialize a csv_file . Arguments Type Intent Optional Attributes Name class( csv_file ), intent(out) :: me character(len=1), intent(in), optional :: quote (Default is \" ) character(len=1), intent(in), optional :: delimiter (Default is , ) logical, intent(in), optional :: enclose_strings_in_quotes if true, all string cells\nwill be enclosed in quotes.\n(Default is True) logical, intent(in), optional :: enclose_all_in_quotes if true, all cells will\nbe enclosed in quotes.\n(Default is False) character(len=1), intent(in), optional :: logical_true_string when writing a logical true value to a CSV file, this\nis the string to use\n(default is T ) character(len=1), intent(in), optional :: logical_false_string when writing a logical false value to a CSV file, this\nis the string to use\n(default is F ) integer, intent(in), optional :: chunk_size factor for expanding vectors\n(default is 100) logical, intent(in), optional :: verbose print error messages to the\nconsole (default is False) private  subroutine destroy_csv_file (me) Destroy the data in a CSV file. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(out) :: me private  subroutine read_csv_file (me, filename, header_row, skip_rows, status_ok, delimiter) Read a CSV file. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: filename the CSV file to open integer, intent(in), optional :: header_row the header row integer, intent(in), optional, dimension(:) :: skip_rows rows to skip logical, intent(out) :: status_ok status flag character(len=1), intent(in), optional :: delimiter (Default is , ) private  subroutine open_csv_file (me, filename, n_cols, status_ok, append) Open a CSV file for writing. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: filename the CSV file to open integer, intent(in) :: n_cols number of columns in the file logical, intent(out) :: status_ok status flag logical, intent(in), optional :: append append if file exists private  subroutine close_csv_file (me, status_ok) Close a CSV file after writing Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me logical, intent(out) :: status_ok status flag private  subroutine add_cell (me, val, int_fmt, real_fmt, trim_str) Add a cell to a CSV file. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in) :: val the value to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. private  subroutine add_vector (me, val, int_fmt, real_fmt, trim_str) Add a vector to a CSV file. Each element is added as a cell to the current line. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. private  subroutine add_matrix (me, val, int_fmt, real_fmt, trim_str) Add a matrix to a CSV file. Each row is added as a new line.\nLine breaks are added at the end of each line (in this way it\ndiffers from the other add routines). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me class(*), intent(in), dimension(:,:) :: val the values to add character(len=*), intent(in), optional :: int_fmt if val is an integer, use\nthis format string. character(len=*), intent(in), optional :: real_fmt if val is a real, use\nthis format string. logical, intent(in), optional :: trim_str if val is a string, then trim it. private  subroutine next_row (me) Advance to the next row in the CSV file\n(write any blank cells that are necessary to finish the row) Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me private  subroutine get_header_csv_str (me, header, status_ok) Returns the header as a type(csv_string) array.\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me type( csv_string ), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok private  subroutine get_header_str (me, header, status_ok) Returns the header as a character(len=*) array.\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:), allocatable :: header logical, intent(out) :: status_ok private  subroutine get_csv_data_as_str (me, csv_data, status_ok) Returns a character(len=*) array containing the csv data\n( read must have already been called to read the file). Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(out), dimension(:,:), allocatable :: csv_data the data logical, intent(out) :: status_ok status flag private pure elemental subroutine to_real_sp (str, val, status_ok) Convert a string to a real(sp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=sp), intent(out) :: val logical, intent(out) :: status_ok private pure elemental subroutine to_real_wp (str, val, status_ok) Convert a string to a real(wp) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str real(kind=wp), intent(out) :: val logical, intent(out) :: status_ok private pure elemental subroutine to_integer (str, val, status_ok) Convert a string to a integer(ip) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer(kind=ip), intent(out) :: val logical, intent(out) :: status_ok private pure elemental subroutine to_logical (str, val, status_ok) Convert a string to a logical Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str logical, intent(out) :: val logical, intent(out) :: status_ok private  subroutine variable_types (me, itypes, status_ok) Returns an array indicating the variable type of each columns. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(out), dimension(:), allocatable :: itypes logical, intent(out) :: status_ok private  subroutine infer_variable_type (str, itype) Infers the variable type, assuming the following precedence: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(out) :: itype private  subroutine csv_get_value (me, row, col, val, status_ok) Get an individual value from the csv_data structure in the CSV class. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: row row number integer, intent(in) :: col column number class(*), intent(out) :: val the returned value logical, intent(out) :: status_ok status flag private  subroutine get_column (me, icol, r, status_ok) Return a column from a CSV file vector. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number class(*), intent(out), dimension(:) :: r assumed to have been allocated to\nthe correct size by the caller.\n( n_rows ) logical, intent(out) :: status_ok status flag private  subroutine get_real_sp_column (me, icol, r, status_ok) Return a column from a CSV file as a real(sp) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=sp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_real_wp_column (me, icol, r, status_ok) Return a column from a CSV file as a real(wp) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number real(kind=wp), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_integer_column (me, icol, r, status_ok) Return a column from a CSV file as a integer(ip) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number integer(kind=ip), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_logical_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a logical vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number logical, intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_character_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a character(len=*) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number character(len=*), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine get_csv_string_column (me, icol, r, status_ok) Convert a column from a csv_string matrix to a type(csv_string) vector. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me integer, intent(in) :: icol column number type( csv_string ), intent(out), dimension(:), allocatable :: r logical, intent(out) :: status_ok private  subroutine tokenize_csv_line (me, line, cells) Tokenize a line from a CSV file. The result is an array of csv_string types. Read more… Arguments Type Intent Optional Attributes Name class( csv_file ), intent(inout) :: me character(len=*), intent(in) :: line type( csv_string ), intent(out), dimension(:), allocatable :: cells private  subroutine read_line_from_file (me, iunit, line, status_ok) Reads the next line from a file. Arguments Type Intent Optional Attributes Name class( csv_file ), intent(in) :: me integer, intent(in) :: iunit character(len=:), intent(out), allocatable :: line logical, intent(out) :: status_ok true if no problems private pure subroutine split (str, token, chunk_size, vals) Split a character string using a token.\n  This routine is inspired by the Python split function. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: token integer, intent(in) :: chunk_size for expanding vectors type( csv_string ), intent(out), dimension(:), allocatable :: vals","tags":"","loc":"module/csv_module.html"},{"title":"csv_utilities – csv-fortran","text":"Utility routines. Uses csv_kinds csv_parameters module~~csv_utilities~~UsesGraph module~csv_utilities csv_utilities module~csv_kinds csv_kinds module~csv_utilities->module~csv_kinds module~csv_parameters csv_parameters module~csv_utilities->module~csv_parameters iso_fortran_env iso_fortran_env module~csv_kinds->iso_fortran_env module~csv_parameters->module~csv_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~csv_utilities~~UsedByGraph module~csv_utilities csv_utilities module~csv_module csv_module module~csv_module->module~csv_utilities Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: max_size_for_insertion_sort = 20 max size for using insertion sort. character(len=*), private, parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' uppercase characters character(len=*), private, parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' lowercase characters Functions public  function unique (vec, chunk_size) result(ivec_unique) Returns only the unique elements of the vector. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: vec a vector of integers integer, intent(in) :: chunk_size chunk size for adding to arrays Return Value integer, dimension(:), allocatable unique elements of ivec public pure function lowercase_string (str) result(s_lower) Returns lowercase version of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str input string Return Value character(len=len=(len(str))) lowercase version of the string Subroutines public pure subroutine expand_vector (vec, n, chunk_size, val, finished) Add elements to the integer vector in chunks. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: vec integer, intent(inout) :: n counter for last element added to vec .\nmust be initialized to size(vec) (or 0 if not allocated) before first call integer, intent(in) :: chunk_size allocate vec in blocks of this size (>0) integer, intent(in), optional :: val the value to add to vec logical, intent(in), optional :: finished set to true to return vec as its correct size ( n ) public  subroutine sort_ascending (ivec) Sorts an integer array ivec in increasing order.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:) :: ivec private pure elemental subroutine swap (i1, i2) Swap two integer values. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: i1 integer, intent(inout) :: i2","tags":"","loc":"module/csv_utilities.html"},{"title":"csv_parameters – csv-fortran","text":"Various parameters. Uses csv_kinds module~~csv_parameters~~UsesGraph module~csv_parameters csv_parameters module~csv_kinds csv_kinds module~csv_parameters->module~csv_kinds iso_fortran_env iso_fortran_env module~csv_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~csv_parameters~~UsedByGraph module~csv_parameters csv_parameters module~csv_module csv_module module~csv_module->module~csv_parameters module~csv_utilities csv_utilities module~csv_module->module~csv_utilities module~csv_utilities->module~csv_parameters Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer(kind=ip), public, parameter :: max_real_str_len = 27 maximum string length of a real number character(len=*), public, parameter :: default_real_fmt = '(E27.17E4)' default real number format statement (for writing real values to strings and files). integer(kind=ip), public, parameter :: max_integer_str_len = 256 maximum string length of an integer. character(len=*), public, parameter :: default_int_fmt = '(I256)' default integer number format statement (for writing real values to strings and files).","tags":"","loc":"module/csv_parameters.html"},{"title":"csv_kinds.f90 – csv-fortran","text":"Files dependent on this one sourcefile~~csv_kinds.f90~~AfferentGraph sourcefile~csv_kinds.f90 csv_kinds.f90 sourcefile~csv_module.f90 csv_module.F90 sourcefile~csv_module.f90->sourcefile~csv_kinds.f90 sourcefile~csv_parameters.f90 csv_parameters.f90 sourcefile~csv_module.f90->sourcefile~csv_parameters.f90 sourcefile~csv_utilities.f90 csv_utilities.f90 sourcefile~csv_module.f90->sourcefile~csv_utilities.f90 sourcefile~csv_parameters.f90->sourcefile~csv_kinds.f90 sourcefile~csv_utilities.f90->sourcefile~csv_kinds.f90 sourcefile~csv_utilities.f90->sourcefile~csv_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Numeric kinds. module csv_kinds use iso_fortran_env , only : real64 , real32 , int32 private integer , parameter , public :: wp = real64 !! default real kind integer , parameter , public :: sp = real32 !! additional real kind, single precision integer , parameter , public :: ip = int32 !! default integer kind end module csv_kinds !*******************************************************************************","tags":"","loc":"sourcefile/csv_kinds.f90.html"},{"title":"csv_module.F90 – csv-fortran","text":"This file depends on sourcefile~~csv_module.f90~~EfferentGraph sourcefile~csv_module.f90 csv_module.F90 sourcefile~csv_kinds.f90 csv_kinds.f90 sourcefile~csv_module.f90->sourcefile~csv_kinds.f90 sourcefile~csv_parameters.f90 csv_parameters.f90 sourcefile~csv_module.f90->sourcefile~csv_parameters.f90 sourcefile~csv_utilities.f90 csv_utilities.f90 sourcefile~csv_module.f90->sourcefile~csv_utilities.f90 sourcefile~csv_parameters.f90->sourcefile~csv_kinds.f90 sourcefile~csv_utilities.f90->sourcefile~csv_kinds.f90 sourcefile~csv_utilities.f90->sourcefile~csv_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  For reading and writing CSV files. module csv_module use csv_utilities use csv_kinds use csv_parameters use iso_fortran_env , only : error_unit implicit none private ! the different types of variables that can be in a CSV file. integer , parameter , public :: csv_type_string = 1 !! a character string cell integer , parameter , public :: csv_type_double = 2 !! a `real(wp)` cell integer , parameter , public :: csv_type_integer = 3 !! an `integer(ip)` cell integer , parameter , public :: csv_type_logical = 4 !! a logical cell real ( wp ), parameter :: zero = 0.0_wp type , public :: csv_string !! a cell from a CSV file. !! !! This is used to store the data internally !! in the [[csv_file]] class. character ( len = :), allocatable :: str end type csv_string type , public :: csv_file !! the main class for reading and writing CSV files. !! !!@note A CSV file is assumed to contain the same number !!      of columns in each row. It may optionally contain !!      a header row. private logical :: verbose = . false . !! to print error messages character ( len = 1 ) :: quote = '\"' !! quotation character character ( len = 1 ) :: delimiter = ',' !! delimiter character ! for reading a csv file: integer :: n_rows = 0 !! number of rows in the file integer :: n_cols = 0 !! number of columns in the file integer :: chunk_size = 1024 !! for expanding vectors type ( csv_string ), dimension (:), allocatable :: header !! the header type ( csv_string ), dimension (:,:), allocatable :: csv_data !! the data in the file ! for writing a csv file: integer :: icol = 0 !! last column written in current row integer :: iunit = 0 !! file unit for writing logical :: enclose_strings_in_quotes = . true . !! if true, all string cells !! will be enclosed in quotes. logical :: enclose_all_in_quotes = . false . !! if true, *all* cells will !! be enclosed in quotes. character ( len = 1 ) :: logical_true_string = 'T' !! when writing a logical `true` !! value to a CSV file, this !! is the string to use !! (default is `T`) character ( len = 1 ) :: logical_false_string = 'F' !! when writing a logical `false` !! value to a CSV file, this !! is the string to use !! (default is `F`) contains private procedure , public :: initialize => initialize_csv_file procedure , public :: read => read_csv_file procedure , public :: destroy => destroy_csv_file procedure , public :: variable_types generic , public :: get_header => get_header_str ,& get_header_csv_str procedure :: get_header_str procedure :: get_header_csv_str !> ! For getting data from the class ! after the file has been read. generic , public :: get => get_csv_data_as_str ,& csv_get_value ,& get_real_sp_column ,& get_real_wp_column ,& get_integer_column ,& get_logical_column ,& get_character_column ,& get_csv_string_column procedure :: get_csv_data_as_str procedure :: csv_get_value procedure :: get_real_sp_column procedure :: get_real_wp_column procedure :: get_integer_column procedure :: get_logical_column procedure :: get_character_column procedure :: get_csv_string_column procedure , public :: open => open_csv_file generic , public :: add => add_cell ,& add_vector ,& add_matrix procedure :: add_cell procedure :: add_vector procedure :: add_matrix procedure , public :: next_row procedure , public :: close => close_csv_file procedure :: tokenize => tokenize_csv_line procedure :: read_line_from_file procedure :: get_column end type csv_file contains !***************************************************************************************** !***************************************************************************************** !> !  Initialize a [[csv_file(type)]]. subroutine initialize_csv_file ( me , quote , delimiter ,& enclose_strings_in_quotes ,& enclose_all_in_quotes ,& logical_true_string ,& logical_false_string ,& chunk_size ,& verbose ) implicit none class ( csv_file ), intent ( out ) :: me character ( len = 1 ), intent ( in ), optional :: quote !! note: can only be one character !! (Default is `\"`) character ( len = 1 ), intent ( in ), optional :: delimiter !! note: can only be one character !! (Default is `,`) logical , intent ( in ), optional :: enclose_strings_in_quotes !! if true, all string cells !! will be enclosed in quotes. !! (Default is True) logical , intent ( in ), optional :: enclose_all_in_quotes !! if true, *all* cells will !! be enclosed in quotes. !! (Default is False) character ( len = 1 ), intent ( in ), optional :: logical_true_string !! when writing a logical `true` !! value to a CSV file, this !! is the string to use !! (default is `T`) character ( len = 1 ), intent ( in ), optional :: logical_false_string !! when writing a logical `false` !! value to a CSV file, this !! is the string to use !! (default is `F`) integer , intent ( in ), optional :: chunk_size !! factor for expanding vectors !! (default is 100) logical , intent ( in ), optional :: verbose !! print error messages to the !! console (default is False) if ( present ( quote )) me % quote = quote if ( present ( delimiter )) me % delimiter = delimiter if ( present ( enclose_strings_in_quotes )) & me % enclose_strings_in_quotes = enclose_strings_in_quotes if ( present ( enclose_all_in_quotes )) & me % enclose_all_in_quotes = enclose_all_in_quotes if ( present ( logical_true_string )) & me % logical_true_string = logical_true_string if ( present ( logical_false_string )) & me % logical_false_string = logical_false_string if ( present ( verbose )) me % verbose = verbose if ( present ( chunk_size )) me % chunk_size = chunk_size ! override: if ( me % enclose_all_in_quotes ) me % enclose_strings_in_quotes = . true . end subroutine initialize_csv_file !***************************************************************************************** !***************************************************************************************** !> !  Destroy the data in a CSV file. subroutine destroy_csv_file ( me ) implicit none class ( csv_file ), intent ( out ) :: me end subroutine destroy_csv_file !***************************************************************************************** !***************************************************************************************** !> !  Read a CSV file. subroutine read_csv_file ( me , filename , header_row , skip_rows , status_ok , delimiter ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! the CSV file to open logical , intent ( out ) :: status_ok !! status flag integer , intent ( in ), optional :: header_row !! the header row integer , dimension (:), intent ( in ), optional :: skip_rows !! rows to skip character ( len = 1 ), intent ( in ), optional :: delimiter !! note: can only be one character !! (Default is `,`) type ( csv_string ), dimension (:), allocatable :: row_data !! a tokenized row integer , dimension (:), allocatable :: rows_to_skip !! the actual rows to skip character ( len = :), allocatable :: line !! a line from the file integer :: i !! counter integer :: j !! counter integer :: irow !! row counter integer :: n_rows_in_file !! number of lines in the file integer :: n_rows !! number of rows in the output data matrix integer :: n_cols !! number of columns in the file (and output data matrix) integer :: istat !! open status flag integer :: iunit !! open file unit logical :: arrays_allocated !! if the arrays in the !! class have been allocated integer :: iheader !! row number of header row !! (0 if no header specified) character ( len = 1 ) :: tmp !! for skipping a row ! clear existing data: arrays_allocated = . false . if ( allocated ( me % csv_data )) deallocate ( me % csv_data ) if ( allocated ( me % header )) deallocate ( me % header ) if ( present ( delimiter )) me % delimiter = delimiter open ( newunit = iunit , file = filename , status = 'OLD' , iostat = istat ) if ( istat == 0 ) then !get number of lines in the file n_rows_in_file = number_of_lines_in_file ( iunit ) !get number of lines in the data array if ( present ( skip_rows )) then !get size of unique elements in skip_rows, !and subtract from n_rows_in_file rows_to_skip = unique ( skip_rows , chunk_size = me % chunk_size ) n_rows = n_rows_in_file - size ( rows_to_skip ) else n_rows = n_rows_in_file end if if ( present ( header_row )) then iheader = max ( 0 , header_row ) n_rows = n_rows - merge ( 0 , 1 , iheader == 0 ) else iheader = 0 end if me % n_rows = n_rows ! we don't know the number of columns ! until we parse the first row (or the header) !read each line in the file, parse it, and populate data irow = 0 do i = 1 , n_rows_in_file !! rows in the file ! skip row if necessary if ( allocated ( rows_to_skip )) then if ( any ( i == rows_to_skip )) then read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( istat /= 0 ) then if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error skipping row in file: ' // trim ( filename ) close ( unit = iunit , iostat = istat ) status_ok = . false . return end if cycle end if end if call me % read_line_from_file ( iunit , line , status_ok ) if (. not . status_ok ) return ! file read error call me % tokenize ( line , row_data ) if (. not . arrays_allocated ) then ! note: the number of columns is obtained ! from the first one read. It is assumed ! that each row has the same number of ! columns. n_cols = size ( row_data ) me % n_cols = n_cols allocate ( me % csv_data ( n_rows , n_cols )) if ( iheader /= 0 ) allocate ( me % header ( n_cols )) arrays_allocated = . true . end if if ( i == iheader ) then do j = 1 , me % n_cols me % header ( j )% str = row_data ( j )% str end do else irow = irow + 1 !! row counter in data array do j = 1 , n_cols me % csv_data ( irow , j ) = row_data ( j ) !%str end do end if end do ! close the file close ( unit = iunit , iostat = istat ) status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error opening file: ' // trim ( filename ) status_ok = . false . end if end subroutine read_csv_file !***************************************************************************************** !***************************************************************************************** !> !  Open a CSV file for writing. ! !  Use `initialize` to set options for the CSV file. subroutine open_csv_file ( me , filename , n_cols , status_ok , append ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! the CSV file to open integer , intent ( in ) :: n_cols !! number of columns in the file logical , intent ( out ) :: status_ok !! status flag logical , intent ( in ), optional :: append !! append if file exists integer :: istat !! open `iostat` flag logical :: append_flag !! local copy of `append` argument logical :: file_exists !! if the file exists ! clear existing data: if ( allocated ( me % csv_data )) deallocate ( me % csv_data ) if ( allocated ( me % header )) deallocate ( me % header ) me % n_cols = n_cols ! optional append argument: append_flag = . false . file_exists = . false . if ( present ( append )) then append_flag = append if ( append ) inquire ( file = filename , exist = file_exists ) end if if ( append_flag . and . file_exists ) then open ( newunit = me % iunit , file = filename , status = 'OLD' , position = 'APPEND' , iostat = istat ) else open ( newunit = me % iunit , file = filename , status = 'REPLACE' , iostat = istat ) end if if ( istat == 0 ) then status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error opening file: ' // trim ( filename ) status_ok = . false . end if end subroutine open_csv_file !***************************************************************************************** !***************************************************************************************** !> !  Close a CSV file after writing subroutine close_csv_file ( me , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me logical , intent ( out ) :: status_ok !! status flag integer :: istat !! close `iostat` flag close ( me % iunit , iostat = istat ) status_ok = istat == 0 end subroutine close_csv_file !***************************************************************************************** !***************************************************************************************** !> !  Add a cell to a CSV file. ! !@todo Need to check the `istat` values for errors. subroutine add_cell ( me , val , int_fmt , real_fmt , trim_str ) implicit none class ( csv_file ), intent ( inout ) :: me class ( * ), intent ( in ) :: val !! the value to add character ( len =* ), intent ( in ), optional :: int_fmt !! if `val` is an integer, use !! this format string. character ( len =* ), intent ( in ), optional :: real_fmt !! if `val` is a real, use !! this format string. logical , intent ( in ), optional :: trim_str !! if `val` is a string, then trim it. integer :: istat !! write `iostat` flag character ( len = :), allocatable :: ifmt !! actual format string to use for integers character ( len = :), allocatable :: rfmt !! actual format string to use for reals logical :: trimstr !! if the strings are to be trimmed character ( len = max_real_str_len ) :: real_val !! for writing a real value character ( len = max_integer_str_len ) :: int_val !! for writing an integer value ! make sure the row isn't already finished if ( me % icol < me % n_cols ) then me % icol = me % icol + 1 if ( me % enclose_all_in_quotes ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote end if select type ( val ) type is ( integer ( ip )) if ( present ( int_fmt )) then ifmt = trim ( adjustl ( int_fmt )) else ifmt = default_int_fmt end if write ( int_val , fmt = ifmt , iostat = istat ) val write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( adjustl ( int_val )) type is ( real ( sp )) if ( present ( real_fmt )) then rfmt = trim ( adjustl ( real_fmt )) else rfmt = default_real_fmt end if write ( real_val , fmt = rfmt , iostat = istat ) val write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( adjustl ( real_val )) type is ( real ( wp )) if ( present ( real_fmt )) then rfmt = trim ( adjustl ( real_fmt )) else rfmt = default_real_fmt end if write ( real_val , fmt = rfmt , iostat = istat ) val write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( adjustl ( real_val )) type is ( logical ) if ( val ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % logical_true_string else write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % logical_false_string end if type is ( character ( len =* )) if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote if ( present ( trim_str )) then trimstr = trim_str else trimstr = . false . end if if ( trimstr ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( val ) else write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) val end if if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote type is ( csv_string ) if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote if ( present ( trim_str )) then trimstr = trim_str else trimstr = . false . end if if ( trimstr ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) trim ( val % str ) else write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) val % str end if if ( me % enclose_strings_in_quotes . and . . not . me % enclose_all_in_quotes ) & write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote class default if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error: cannot write unknown variable type to CSV file.' end select if ( me % enclose_all_in_quotes ) then write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % quote end if if ( me % icol < me % n_cols ) write ( me % iunit , fmt = '(A)' , advance = 'NO' , iostat = istat ) me % delimiter else if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error: cannot write more cells to the current row.' end if end subroutine add_cell !***************************************************************************************** !***************************************************************************************** !> !  Add a vector to a CSV file. Each element is added as a cell to the current line. subroutine add_vector ( me , val , int_fmt , real_fmt , trim_str ) implicit none class ( csv_file ), intent ( inout ) :: me class ( * ), dimension (:), intent ( in ) :: val !! the values to add character ( len =* ), intent ( in ), optional :: int_fmt !! if `val` is an integer, use !! this format string. character ( len =* ), intent ( in ), optional :: real_fmt !! if `val` is a real, use !! this format string. logical , intent ( in ), optional :: trim_str !! if `val` is a string, then trim it. integer :: i !! counter do i = 1 , size ( val ) #if ( defined __GFORTRAN__ ) && ( __GNUC__ <= 10 ) ! This is a stupid workaround for gfortran bugs (tested with 7.2.0) select type ( val ) type is ( character ( len =* )) call me % add ( val ( i ), int_fmt , real_fmt , trim_str ) class default call me % add ( val ( i ), int_fmt , real_fmt , trim_str ) end select #else call me % add ( val ( i ), int_fmt , real_fmt , trim_str ) #endif end do end subroutine add_vector !***************************************************************************************** !***************************************************************************************** !> !  Add a matrix to a CSV file. Each row is added as a new line. !  Line breaks are added at the end of each line (in this way it !  differs from the other `add` routines). subroutine add_matrix ( me , val , int_fmt , real_fmt , trim_str ) implicit none class ( csv_file ), intent ( inout ) :: me class ( * ), dimension (:,:), intent ( in ) :: val !! the values to add character ( len =* ), intent ( in ), optional :: int_fmt !! if `val` is an integer, use !! this format string. character ( len =* ), intent ( in ), optional :: real_fmt !! if `val` is a real, use !! this format string. logical , intent ( in ), optional :: trim_str !! if `val` is a string, then trim it. integer :: i !! counter ! add each row: do i = 1 , size ( val , 1 ) call me % add ( val ( i ,:), int_fmt , real_fmt , trim_str ) call me % next_row () end do end subroutine add_matrix !***************************************************************************************** !***************************************************************************************** !> !  Advance to the next row in the CSV file !  (write any blank cells that are necessary to finish the row) subroutine next_row ( me ) implicit none class ( csv_file ), intent ( inout ) :: me integer :: i !! counter integer :: n !! number of blank cells to write if ( me % icol > 0 ) then n = me % n_cols - me % icol do i = 1 , n if ( i == n ) then !no trailing delimiter if ( me % enclose_strings_in_quotes ) then write ( me % iunit , '(A)' , advance = 'NO' ) me % quote // me % quote end if else if ( me % enclose_strings_in_quotes ) then write ( me % iunit , '(A)' , advance = 'NO' ) me % quote // me % quote // me % delimiter else write ( me % iunit , '(A)' , advance = 'NO' ) me % delimiter end if end if end do write ( me % iunit , '(A)' ) '' ! new line end if me % icol = 0 ! this row is finished end subroutine next_row !***************************************************************************************** !***************************************************************************************** !> !  Returns the header as a `type(csv_string)` array. !  (`read` must have already been called to read the file). subroutine get_header_csv_str ( me , header , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me type ( csv_string ), dimension (:), allocatable , intent ( out ) :: header logical , intent ( out ) :: status_ok integer :: i !! column counter if ( allocated ( me % header )) then allocate ( header ( me % n_cols )) do i = 1 , me % n_cols header ( i ) = me % header ( i ) end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) 'Error: no header in class.' status_ok = . false . end if end subroutine get_header_csv_str !***************************************************************************************** !***************************************************************************************** !> !  Returns the header as a `character(len=*)` array. !  (`read` must have already been called to read the file). subroutine get_header_str ( me , header , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), dimension (:), allocatable , intent ( out ) :: header logical , intent ( out ) :: status_ok integer :: i !! column counter if ( allocated ( me % header )) then allocate ( header ( me % n_cols )) do i = 1 , me % n_cols header ( i ) = me % header ( i )% str end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A)' ) 'Error: no header in class.' status_ok = . false . end if end subroutine get_header_str !***************************************************************************************** !***************************************************************************************** !> !  Returns a `character(len=*)` array containing the csv data !  (`read` must have already been called to read the file). subroutine get_csv_data_as_str ( me , csv_data , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), dimension (:,:), allocatable , intent ( out ) :: csv_data !! the data logical , intent ( out ) :: status_ok !! status flag integer :: i !! row counter integer :: j !! column counter if ( allocated ( me % csv_data )) then ! size the output array: allocate ( csv_data ( me % n_rows , me % n_cols )) ! convert each element to a string: do concurrent ( j = 1 : me % n_cols ) do concurrent ( i = 1 : me % n_rows ) csv_data ( i , j ) = me % csv_data ( i , j )% str end do end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_csv_data_as_str !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a `real(sp)` pure elemental subroutine to_real_sp ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str real ( sp ), intent ( out ) :: val logical , intent ( out ) :: status_ok integer :: istat !! read `iostat` error code read ( str , fmt =* , iostat = istat ) val if ( istat == 0 ) then status_ok = . true . else status_ok = . false . val = zero end if end subroutine to_real_sp !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a `real(wp)` pure elemental subroutine to_real_wp ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str real ( wp ), intent ( out ) :: val logical , intent ( out ) :: status_ok integer :: istat !! read `iostat` error code read ( str , fmt =* , iostat = istat ) val if ( istat == 0 ) then status_ok = . true . else status_ok = . false . val = zero end if end subroutine to_real_wp !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a `integer(ip)` pure elemental subroutine to_integer ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str integer ( ip ), intent ( out ) :: val logical , intent ( out ) :: status_ok integer :: istat !! read `iostat` error code read ( str , fmt = default_int_fmt , iostat = istat ) val if ( istat == 0 ) then status_ok = . true . else status_ok = . false . val = 0 end if end subroutine to_integer !***************************************************************************************** !***************************************************************************************** !> !  Convert a string to a `logical` ! !  * Evaluates to `.true.`  for strings ['1','t','true','.true.'] !  * Evaluates to `.false.` for strings ['0','f','false','.false.'] ! !  The string match is not case sensitive. pure elemental subroutine to_logical ( str , val , status_ok ) implicit none character ( len =* ), intent ( in ) :: str logical , intent ( out ) :: val logical , intent ( out ) :: status_ok character ( len = :), allocatable :: tmp ! True and False options (all lowercase): character ( len =* ), dimension ( 4 ), parameter :: true_str = [ '1     ' ,& 't     ' ,& 'true  ' ,& '.true.' ] character ( len =* ), dimension ( 4 ), parameter :: false_str = [ '0      ' ,& 'f      ' ,& 'false  ' ,& '.false.' ] tmp = lowercase_string ( str ) if ( any ( tmp == true_str ) ) then val = . true . status_ok = . true . else if ( any ( tmp == false_str ) ) then val = . false . status_ok = . true . else val = . false . status_ok = . false . end if end subroutine to_logical !***************************************************************************************** !***************************************************************************************** !> !  Returns an array indicating the variable type of each columns. ! !@note The first element in the column is used to determine the type. subroutine variable_types ( me , itypes , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , dimension (:), allocatable , intent ( out ) :: itypes logical , intent ( out ) :: status_ok integer :: i !! counter if ( allocated ( me % csv_data )) then allocate ( itypes ( me % n_cols )) do i = 1 , me % n_cols call infer_variable_type ( me % csv_data ( 1 , i )% str , itypes ( i )) end do status_ok = . true . else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine variable_types !***************************************************************************************** !***************************************************************************************** !> !  Infers the variable type, assuming the following precedence: ! !  * integer !  * double !  * logical !  * character subroutine infer_variable_type ( str , itype ) implicit none character ( len =* ), intent ( in ) :: str integer , intent ( out ) :: itype real ( wp ) :: rval !! a real value integer ( ip ) :: ival !! an iteger value logical :: lval !! a logical value logical :: status_ok !! status flag call to_integer ( str , ival , status_ok ) if ( status_ok ) then itype = csv_type_integer return end if call to_real_wp ( str , rval , status_ok ) if ( status_ok ) then itype = csv_type_double return end if call to_logical ( str , lval , status_ok ) if ( status_ok ) then itype = csv_type_logical return end if ! default is string: itype = csv_type_string end subroutine infer_variable_type !***************************************************************************************** !***************************************************************************************** !> !  Get an individual value from the `csv_data` structure in the CSV class. ! !  The output `val` can be an `integer(ip)`, `real(wp)`, !  `logical`, or `character(len=*)` variable. subroutine csv_get_value ( me , row , col , val , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: row !! row number integer , intent ( in ) :: col !! column number class ( * ), intent ( out ) :: val !! the returned value logical , intent ( out ) :: status_ok !! status flag select type ( val ) type is ( integer ( ip )) call to_integer ( me % csv_data ( row , col )% str , val , status_ok ) type is ( real ( sp )) call to_real_sp ( me % csv_data ( row , col )% str , val , status_ok ) type is ( real ( wp )) call to_real_wp ( me % csv_data ( row , col )% str , val , status_ok ) type is ( logical ) call to_logical ( me % csv_data ( row , col )% str , val , status_ok ) type is ( character ( len =* )) status_ok = . true . if ( allocated ( me % csv_data ( row , col )% str )) then val = me % csv_data ( row , col )% str else val = '' end if type is ( csv_string ) status_ok = . true . val = me % csv_data ( row , col ) class default status_ok = . false . end select end subroutine csv_get_value !***************************************************************************************** !***************************************************************************************** !> !  Return a column from a CSV file vector. ! !@note This routine requires that the `r` array already be allocated. !      This is because Fortran doesn't want to allow to you pass !      a non-polymorphic variable into a routine with a dummy variable !      with `class(*),dimension(:),allocatable,intent(out)` attributes. subroutine get_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number class ( * ), dimension (:), intent ( out ) :: r !! assumed to have been allocated to !! the correct size by the caller. !! (`n_rows`) logical , intent ( out ) :: status_ok !! status flag integer :: i !! counter character ( len = :), allocatable :: tmp !! for gfortran workaround ! we know the data is allocated, since that ! was checked by the calling routines. if ( me % n_cols >= icol . and . icol > 0 ) then do i = 1 , me % n_rows ! row loop #if ( defined __GFORTRAN__ ) && ( __GNUC__ <= 10 ) ! the following is a workaround for gfortran bugs: select type ( r ) type is ( character ( len =* )) tmp = repeat ( ' ' , len ( r )) ! size the string call me % csv_get_value ( i , icol , tmp , status_ok ) r ( i ) = tmp class default call me % csv_get_value ( i , icol , r ( i ), status_ok ) end select #else call me % csv_get_value ( i , icol , r ( i ), status_ok ) #endif if (. not . status_ok ) then select type ( r ) ! note: character conversion can never fail, so not ! checking for that here. also we know it is real, ! integer, or logical at this point. type is ( integer ( ip )) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to integer: ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = 0 type is ( real ( sp )) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to real(real32): ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = zero type is ( real ( wp )) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to real(real64): ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = zero type is ( logical ) if ( me % verbose ) write ( error_unit , '(A)' ) & 'Error converting string to logical: ' // trim ( me % csv_data ( i , icol )% str ) r ( i ) = . false . end select end if end do else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: invalid column number: ' , icol status_ok = . false . end if end subroutine get_column !***************************************************************************************** !***************************************************************************************** !> !  Return a column from a CSV file as a `real(sp)` vector. subroutine get_real_sp_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number real ( sp ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_real_sp_column !***************************************************************************************** !***************************************************************************************** !> !  Return a column from a CSV file as a `real(wp)` vector. subroutine get_real_wp_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number real ( wp ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_real_wp_column !***************************************************************************************** !***************************************************************************************** !> !  Return a column from a CSV file as a `integer(ip)` vector. subroutine get_integer_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number integer ( ip ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_integer_column !***************************************************************************************** !***************************************************************************************** !> !  Convert a column from a `csv_string` matrix to a `logical` vector. subroutine get_logical_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number logical , dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_logical_column !***************************************************************************************** !***************************************************************************************** !> !  Convert a column from a `csv_string` matrix to a `character(len=*)` vector. subroutine get_character_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number character ( len =* ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_character_column !***************************************************************************************** !***************************************************************************************** !> !  Convert a column from a `csv_string` matrix to a `type(csv_string)` vector. subroutine get_csv_string_column ( me , icol , r , status_ok ) implicit none class ( csv_file ), intent ( inout ) :: me integer , intent ( in ) :: icol !! column number type ( csv_string ), dimension (:), allocatable , intent ( out ) :: r logical , intent ( out ) :: status_ok if ( allocated ( me % csv_data )) then allocate ( r ( me % n_rows )) ! size the output vector call me % get_column ( icol , r , status_ok ) else if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Error: class has not been initialized' status_ok = . false . end if end subroutine get_csv_string_column !***************************************************************************************** !***************************************************************************************** !> !  Tokenize a line from a CSV file. The result is an array of `csv_string` types. ! !### Notes !  * Quotes are removed if the entire cell is contained in quotes. ! !@warning It does not account for delimiters in quotes !         (these are treated as a new cell). Need to fix! subroutine tokenize_csv_line ( me , line , cells ) implicit none class ( csv_file ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: line type ( csv_string ), dimension (:), allocatable , intent ( out ) :: cells integer :: i !! counter character ( len = :), allocatable :: tmp !! a temp string with whitespace removed integer :: n !! length of compressed string call split ( line , me % delimiter , me % chunk_size , cells ) ! remove quotes if present: do i = 1 , size ( cells ) ! remove whitespace from the string: tmp = trim ( adjustl ( cells ( i )% str )) n = len ( tmp ) if ( n > 1 ) then ! if the first and last non-blank character is ! a quote, then remove them and replace with what ! is inside the quotes. Otherwise, leave it as is. if ( tmp ( 1 : 1 ) == me % quote . and . tmp ( n : n ) == me % quote ) then if ( n > 2 ) then cells ( i )% str = tmp ( 2 : n - 1 ) ! remove the quotes else cells ( i )% str = '' ! empty string end if end if end if end do end subroutine tokenize_csv_line !***************************************************************************************** !***************************************************************************************** !> !  Returns the number of lines in a text file. ! !@note It rewinds the file back to the beginning when finished. function number_of_lines_in_file ( iunit ) result ( n_lines ) implicit none integer , intent ( in ) :: iunit !! the file unit number !! (assumed to be open) integer :: n_lines !! the number of lines in the file character ( len = 1 ) :: tmp integer :: istat rewind ( iunit ) n_lines = 0 do read ( iunit , fmt = '(A1)' , iostat = istat ) tmp if ( is_iostat_end ( istat )) exit n_lines = n_lines + 1 end do rewind ( iunit ) end function number_of_lines_in_file !***************************************************************************************** !***************************************************************************************** !> !  Reads the next line from a file. subroutine read_line_from_file ( me , iunit , line , status_ok ) implicit none class ( csv_file ), intent ( in ) :: me integer , intent ( in ) :: iunit character ( len = :), allocatable , intent ( out ) :: line logical , intent ( out ) :: status_ok !! true if no problems integer :: nread !! character count specifier for read statement integer :: istat !! file read io status flag character ( len = me % chunk_size ) :: buffer !! the file read buffer nread = 0 buffer = '' line = '' status_ok = . true . do ! read in the next block of text from the line: read ( iunit , fmt = '(A)' , advance = 'NO' , size = nread , iostat = istat ) buffer if ( IS_IOSTAT_END ( istat ) . or . IS_IOSTAT_EOR ( istat )) then ! add the last block of text before the end of record if ( nread > 0 ) line = line // buffer ( 1 : nread ) exit else if ( istat == 0 ) then ! all the characters were read line = line // buffer ! add this block of text to the string else ! some kind of error if ( me % verbose ) write ( error_unit , '(A,1X,I5)' ) 'Read error for file unit: ' , iunit status_ok = . false . exit end if end do end subroutine read_line_from_file !***************************************************************************************** !***************************************************************************************** !> !  Split a character string using a token. !  This routine is inspired by the Python split function. ! !### Example !````Fortran !   character(len=:),allocatable :: s !   type(csv_string),dimension(:),allocatable :: vals !   s = '1,2,3,4,5' !   call split(s,',',vals) !```` ! !@warning Does not account for tokens contained within quotes string !!! pure subroutine split ( str , token , chunk_size , vals ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ) :: token integer , intent ( in ) :: chunk_size !! for expanding vectors type ( csv_string ), dimension (:), allocatable , intent ( out ) :: vals integer :: i !! counter integer :: len_str !! significant length of `str` integer :: len_token !! length of the token integer :: n_tokens !! number of tokens integer :: i1 !! index integer :: i2 !! index integer :: j !! counters integer , dimension (:), allocatable :: itokens !! start indices of the !! token locations in `str` len_token = len ( token ) ! length of the token n_tokens = 0 ! initialize the token counter j = 0 ! index to start looking for the next token ! first, count the number of times the token ! appears in the string, and get the token indices. ! ! Examples: !  ',         '    --> 1 !  '1234,67,90'    --> 5,8 !  '123,      '    --> 4 ! length of the string if ( token == ' ' ) then ! in this case, we can't ignore trailing space len_str = len ( str ) else ! safe to ignore trailing space when looking for tokens len_str = len_trim ( str ) end if j = 1 n_tokens = 0 do if ( j > len_str ) exit ! end of string, finished i = index ( str ( j :), token ) ! index of next token in remaining string if ( i <= 0 ) exit ! no more tokens found call expand_vector ( itokens , n_tokens , chunk_size , i + j - 1 ) ! save the token location j = j + i + ( len_token - 1 ) end do call expand_vector ( itokens , n_tokens , chunk_size , finished = . true .) ! resize the vector allocate ( vals ( n_tokens + 1 )) if ( n_tokens > 0 ) then len_str = len ( str ) i1 = 1 i2 = itokens ( 1 ) - 1 if ( i2 >= i1 ) then vals ( 1 )% str = str ( i1 : i2 ) else vals ( 1 )% str = '' !the first character is a token end if !      1 2 3 !    'a,b,c,d' do i = 2 , n_tokens i1 = itokens ( i - 1 ) + len_token i2 = itokens ( i ) - 1 if ( i2 >= i1 ) then vals ( i )% str = str ( i1 : i2 ) else vals ( i )% str = '' !empty element (e.g., 'abc,,def') end if end do i1 = itokens ( n_tokens ) + len_token i2 = len_str if ( itokens ( n_tokens ) + len_token <= len_str ) then vals ( n_tokens + 1 )% str = str ( i1 : i2 ) else vals ( n_tokens + 1 )% str = '' !the last character was a token end if else !no tokens present, so just return the original string: vals ( 1 )% str = str end if end subroutine split !***************************************************************************************** !***************************************************************************************** end module csv_module !*****************************************************************************************","tags":"","loc":"sourcefile/csv_module.f90.html"},{"title":"csv_utilities.f90 – csv-fortran","text":"This file depends on sourcefile~~csv_utilities.f90~~EfferentGraph sourcefile~csv_utilities.f90 csv_utilities.f90 sourcefile~csv_kinds.f90 csv_kinds.f90 sourcefile~csv_utilities.f90->sourcefile~csv_kinds.f90 sourcefile~csv_parameters.f90 csv_parameters.f90 sourcefile~csv_utilities.f90->sourcefile~csv_parameters.f90 sourcefile~csv_parameters.f90->sourcefile~csv_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~csv_utilities.f90~~AfferentGraph sourcefile~csv_utilities.f90 csv_utilities.f90 sourcefile~csv_module.f90 csv_module.F90 sourcefile~csv_module.f90->sourcefile~csv_utilities.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams ! !  Utility routines. module csv_utilities use csv_kinds use csv_parameters private integer , parameter :: max_size_for_insertion_sort = 20 !! max size for using insertion sort. character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters public :: unique public :: expand_vector public :: sort_ascending public :: lowercase_string contains !******************************************************************************* !******************************************************************************* !> !  Add elements to the integer vector in chunks. pure subroutine expand_vector ( vec , n , chunk_size , val , finished ) implicit none integer , dimension (:), allocatable , intent ( inout ) :: vec integer , intent ( inout ) :: n !! counter for last element added to `vec`. !! must be initialized to `size(vec)` !! (or 0 if not allocated) before first call integer , intent ( in ) :: chunk_size !! allocate `vec` in blocks of this size (>0) integer , intent ( in ), optional :: val !! the value to add to `vec` logical , intent ( in ), optional :: finished !! set to true to return `vec` !! as its correct size (`n`) integer , dimension (:), allocatable :: tmp !! temporary array if ( present ( val )) then if ( allocated ( vec )) then if ( n == size ( vec )) then ! have to add another chunk: allocate ( tmp ( size ( vec ) + chunk_size )) tmp ( 1 : size ( vec )) = vec call move_alloc ( tmp , vec ) end if n = n + 1 else ! the first element: allocate ( vec ( chunk_size )) n = 1 end if vec ( n ) = val end if if ( present ( finished )) then if ( finished ) then ! set vec to actual size (n): if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp ( n )) tmp = vec ( 1 : n ) call move_alloc ( tmp , vec ) end if end if end subroutine expand_vector !******************************************************************************* !******************************************************************************* !> !  Returns only the unique elements of the vector. function unique ( vec , chunk_size ) result ( ivec_unique ) implicit none integer , dimension (:), intent ( in ) :: vec !! a vector of integers integer , intent ( in ) :: chunk_size !! chunk size for adding to arrays integer , dimension (:), allocatable :: ivec_unique !! unique elements of `ivec` integer , dimension ( size ( vec )) :: ivec !! temp copy of vec integer :: i !! counter integer :: n !! number of unique elements ! first we sort it: ivec = vec ! make a copy call sort_ascending ( ivec ) ! add the first element: n = 1 ivec_unique = [ ivec ( 1 )] ! walk through array and get the unique ones: if ( size ( ivec ) > 1 ) then do i = 2 , size ( ivec ) if ( ivec ( i ) /= ivec ( i - 1 )) then call expand_vector ( ivec_unique , n , chunk_size , val = ivec ( i )) end if end do call expand_vector ( ivec_unique , n , chunk_size , finished = . true .) end if end function unique !******************************************************************************* !******************************************************************************* !> !  Sorts an integer array `ivec` in increasing order. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending ( ivec ) implicit none integer , dimension (:), intent ( inout ) :: ivec call quicksort ( 1 , size ( ivec )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer :: ipivot !! pivot element integer :: i !! counter integer :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1 , ihigh do j = i , ilow + 1 , - 1 if ( ivec ( j ) < ivec ( j - 1 ) ) then call swap ( ivec ( j ), ivec ( j - 1 )) else exit end if end do end do else if ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1 ) call quicksort ( ipivot + 1 , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. implicit none integer , intent ( in ) :: ilow integer , intent ( in ) :: ihigh integer , intent ( out ) :: ipivot integer :: i , ip call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2 )) ip = ilow do i = ilow + 1 , ihigh if ( ivec ( i ) < ivec ( ilow ) ) then ip = ip + 1 call swap ( ivec ( ip ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ip )) ipivot = ip end subroutine partition end subroutine sort_ascending !******************************************************************************* !******************************************************************************* !> !  Swap two integer values. pure elemental subroutine swap ( i1 , i2 ) implicit none integer , intent ( inout ) :: i1 integer , intent ( inout ) :: i2 integer :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap !******************************************************************************* !******************************************************************************* !> !  Returns lowercase version of the string. pure function lowercase_string ( str ) result ( s_lower ) implicit none character ( len =* ), intent ( in ) :: str !! input string character ( len = ( len ( str ))) :: s_lower !! lowercase version of the string integer :: i !! counter integer :: j !! index of uppercase character s_lower = str do i = 1 , len_trim ( str ) j = index ( upper , s_lower ( i : i )) if ( j > 0 ) s_lower ( i : i ) = lower ( j : j ) end do end function lowercase_string !******************************************************************************* !******************************************************************************* end module csv_utilities !*******************************************************************************","tags":"","loc":"sourcefile/csv_utilities.f90.html"},{"title":"csv_parameters.f90 – csv-fortran","text":"This file depends on sourcefile~~csv_parameters.f90~~EfferentGraph sourcefile~csv_parameters.f90 csv_parameters.f90 sourcefile~csv_kinds.f90 csv_kinds.f90 sourcefile~csv_parameters.f90->sourcefile~csv_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~csv_parameters.f90~~AfferentGraph sourcefile~csv_parameters.f90 csv_parameters.f90 sourcefile~csv_module.f90 csv_module.F90 sourcefile~csv_module.f90->sourcefile~csv_parameters.f90 sourcefile~csv_utilities.f90 csv_utilities.f90 sourcefile~csv_module.f90->sourcefile~csv_utilities.f90 sourcefile~csv_utilities.f90->sourcefile~csv_parameters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Various parameters. module csv_parameters use csv_kinds private integer ( ip ), parameter , public :: max_real_str_len = 27 !! maximum string length of a real number character ( len =* ), parameter , public :: default_real_fmt = '(E27.17E4)' !! default real number format statement (for writing real values to strings and files). integer ( ip ), parameter , public :: max_integer_str_len = 256 !! maximum string length of an integer. character ( len =* ), parameter , public :: default_int_fmt = '(I256)' !! default integer number format statement (for writing real values to strings and files). end module csv_parameters !*******************************************************************************","tags":"","loc":"sourcefile/csv_parameters.f90.html"}]}